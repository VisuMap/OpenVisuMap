import numpy as np
import math, random, time

GENE_TABLE = 'Gene Features'
ALPHABET = 'ARNDCEQGHILKMFPSTWYV'
P = {ALPHABET[k]:k for k in range(len(ALPHABET))}
P3 = {'ALA':'A', 'ARG':'R', 'ASN':'N', 'ASP':'D', 'CYS':'C',
      'GLU':'E', 'GLN':'Q', 'GLY':'G', 'HIS':'H', 'ILE':'I',
		'LEU':'L', 'LYS':'K', 'MET':'M', 'PHE':'F', 'PRO':'P',
		'SER':'S', 'THR':'T', 'TRP':'W', 'TYR':'Y', 'VAL':'V'}

def FilterSeq(D, P):
	return ''.join([ c for c in D.upper() if c in P ])

def GetProteinTable(dsName):
	if vv.Dataset.Name != dsName:
		pTable = vv.Folder.ReadDataset(dsName)
	else:
		pTable = vv.Dataset
	return pTable

def AssertProteinTable():
	if (vv.Dataset.Columns < 4) or ( vv.Dataset.ColumnSpecList[2].Id != 'ProteinSeq'):
		vv.Message('The current dataset is not a protein table')
		vv.Return()
	return vv.Dataset

def AssertSeqMap(pMap):
	info = MapInfo(pMap.Description)
	if info.pId != None:
		return
	else:
		vv.Message('The view is not a protein seq map')
		vv.Return()

def GetProteinSeq(pTable, pId):
	rowIdx = pTable.IndexOfRow(pId)
	return pTable.GetDataAt(rowIdx, 2)

def LoadSeqModeling(seqdll = 'SeqModeling.dll', className = 'VisuMap.SeqModeling'):
	from shutil import copy
	from os.path import exists
	from os import stat
	dllFile = vv.CurrentScriptDirectory + '/' + seqdll
	srcFile = vv.CurrentScriptDirectory + '/' + 'SeqModeling.cs'
	if not exists(dllFile) or stat(dllFile).st_mtime < stat(srcFile).st_mtime:
		msbuild = '"C:/Program Files (x86)/Microsoft Visual Studio/2017/Professional/MSBuild/15.0/Bin/MSBuild.exe"'
		vv.StartProcess(msbuild, 'SeqModeling.csproj /p:Configuration=Release', False).WaitForExit(1000)
		copy(vv.CurrentScriptDirectory + '/bin/Release/' + seqdll, vv.CurrentScriptDirectory)
	#dllFile = vv.CurrentScriptDirectory + '/bin/Debug/SeqModeling.dll'
	vv.LoadLibrary(dllFile)
	return New.Instance(className)

if 'cs' not in globals():
	cs = LoadSeqModeling()


# protein embedding map information
class MapInfo():
	def __init__(self, initStr = None):
		for nm in 'pId,Gene,pLen,Epochs,InitE,FinalE,PP,WinSize,AugCfg,Is3D,Mtd,SF,CF,PT'.split(','):
			setattr(self, nm, None)
		if initStr is not None:
			self.ParseStr(initStr)
	def Init(self, epochs, is3D, initExag, finalExag, ppl):
		self.Epochs = epochs
		self.Is3D = is3D
		self.InitE = initExag
		self.FinalE = finalExag
		self.PP = ppl
		return self
	def SetMds(self, mds):
		self.Epochs = mds.MaxLoops
		self.InitE = mds.InitialExaggeration
		self.FinalE = mds.ExaggerationFinal
		self.PP = mds.PerplexityRatio
		self.Is3D = mds.Is3D
		return self		
	def ToStr(self):
		dic = self.__dict__
		return ';'.join([f'{key}:{str(dic[key])}' for  key in dic if dic[key] is not None])
	def ParseStr(self, initStr):
		dic = self.__dict__
		for f in initStr.split(';'):
			if f is not None:
				fs = f.split(':')
				if len(fs) == 2:
					dic[fs[0]] = fs[1]

class AtlasMapStore():	
	def __init__(self, atName, is3D):
		self.atlas = vv.AtlasManager.OpenAtlas(atName)
		self.viewName = 'D3dRender' if is3D else 'MapSnapshot'
		self.atlas.TheForm.Hide()
	def AddMaps(self):
		for fm in vv.FindFormList(self.viewName):
			item = self.atlas.CaptureItem(fm)
			item.Name = MapInfo(fm.Description).pId
			fm.Close()
	def Close(self):
		self.atlas.Close()

def NewMapStore(atName, is3D=True):
	if atName is None:
		return None
	return AtlasMapStore(atName, is3D)

#-----------------------------------------------------------
# Code to maintain the protein table.
#-----------------------------------------------------------

def Sym2Id(ds, gSymbol):
	for row in range(ds.Rows):
		if ds.GetDataAt(row, 5) == gSymbol:
			return ds.BodyList[row].Id
	print('Cannot find gene ' + gSymbol)
	return None

def Id2Sym(ds, gId):
	rowIdx = ds.IndexOfRow(gId)
	if rowIdx >= 0:
		return ds.GetDataAt(rowIdx, 5)
	else:
		return None

def GetProteinIds(ds, gId):
	rowIdx = ds.IndexOfRow(gId)
	if rowIdx >= 0:
		pList = ds.GetDataAt(rowIdx, 17)
		return pList.split(',')
	else:
		return None

def ParseXml(pList, maxCount, minLen, maxLen):
	import urllib.request
	pList = pList[:100]
	rqUrl='https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=protein&&api_key=f415a83f720db9a3ed1693cfd833cef27208&id=' + ','.join(pList)
	xmlDoc = urllib.request.urlopen(rqUrl).read().decode('utf-8')
	infoList = []
	used = set()
	pLen, pName = 0, ''
	for s in xmlDoc.splitlines():
		if s.find('"Length"') > 0:
			pLen = int( s.split('>')[1][:-6] )
		if s.find('"AccessionVersion"') > 0:
			pName = s.split('>')[1][:-6]
			if (pLen>=minLen) and (pLen<maxLen) and (pLen not in used):
				infoList.append( (pName, pLen) )
				used.add(pLen)
		if len(infoList) >= maxCount:
			break
	return infoList

def AddProteins(ds, gId, maxCount=20, minLen=400, maxLen=1000_000):
	import urllib.request
	getUrl = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi?db=protein&rettype=fasta&retmode=text&api_key=f415a83f720db9a3ed1693cfd833cef27208&id='
	gSymbol = Id2Sym(ds, gId)
	pList = GetProteinIds(ds, gId)
	if len(pList) == 0 or pList[0] == "-":
		return gSymbol, 0
	random.shuffle(pList)
	infoList = ParseXml(pList, maxCount, minLen, maxLen)
	if len(infoList) == 0:
		return gSymbol, 0

	typeIdx = max([b.Type for b in vv.Dataset.BodyList]) + 1 if vv.Dataset.BodyCount > 0 else 0
	pIds = ','.join([ pId for (pId, _) in infoList ])
	sFastaList = urllib.request.urlopen(getUrl+pIds).read().decode('utf-8')
	fastaList = sFastaList.split('>')
	vv.DoEvents()
	if vv.GuiManager.StopFlag:
		vv.Return()

	for s in fastaList:
		sFasta = s.strip()
		if len(sFasta) == 0:
			continue
		idx = sFasta.index('\n')
		desc = gId + ': ' + sFasta[0:idx]
		idx2 = sFasta.index(' ')
		pId = sFasta[:idx2]
		pSeq = FilterSeq(sFasta[idx:], P)
		pLen = len(pSeq)
		vv.Dataset.AddRow(pId, gSymbol, typeIdx, [desc,gSymbol,pSeq,str(pLen)])
	vv.Dataset.CommitChanges()
	return gSymbol, len(infoList)

def LoadProteins(startIndex=0):
	ds = vv.Folder.ReadDataset(GENE_TABLE)
	pTotal = 0
	for nr, g in enumerate( [b.Id for b in ds.BodyList] ):
		if nr >= startIndex:
			gSymbol, cnt = AddProteins(ds, g, maxCount=20, minLen=50, maxLen=400)
			pTotal += cnt
			if cnt != 0:
				print(f'{nr}: {gSymbol:<12} {cnt:>4}  \t{pTotal}')
	print('<<<<<<<<<<<<<<<    Done  >>>>>>>>>>>>>>>>>')

def NewRandomTable(N):
	import random
	aaDist = list(vv.AtlasManager.ReadValueList('TestMaps', 'i2'))
	aaList = ''.join([x.Id*int(x.Value*10000) for x in aaDist])
	aaL, row, ds = len(aaList)-1, 1, vv.Dataset
	for n in range(N):
		L = random.randint(500, 5000)
		s = ''.join([aaList[random.randint(0, aaL)] for k in range(L)])
		ds.AddRow("R"+str(n), '', 0, ['', '', s, str(len(s))])
	ds.CommitChanges()

#NewRandomTable(10000)

def CreateProteinMapByCounts(idList, repeats=1, epochs=5000, initExag=3.0, finalExag=1.0, ppl=0.1, is3D=False):
	from collections import Counter
	pTable = AssertProteinTable()	
	rows = len(idList)
	columns = len(ALPHABET)
	if rows == 0:
		bsList = pTable.BodyListEnabled()
		rows = bsList.Count
		idList = [b.Id for b in bsList]
		print(bsList.Count, rows, len(idList))
	else:
		bsList = pTable.BodyListForId(idList)
	nt = New.NumberTable(bsList, columns)
	for row in range(rows):
		pSeq = GetProteinSeq(pTable, idList[row])
		pCnt = Counter(pSeq)
		R = nt.Matrix[row]
		fct = 10000/len(pSeq)
		for c, a in enumerate(ALPHABET):
			R[c] =fct*pCnt[a]
	for c, a in enumerate(ALPHABET):
		nt.ColumnSpecList[c].Id = a
	mds = NewMds(nt, epochs=epochs, initExag=initExag, finalExag=finalExag, ppl=ppl, is3D=is3D)
	mds.RefreshFreq = 50
	info = MapInfo().Init(epochs, is3D, initExag, finalExag, ppl)
	info.Mtd = 'PmCnt'
	RunMds(mds, repeats, info=info)
	if repeats>= 1:
		mds.Close()

def CreateProteinMap1(idList, epochs=5000, is3D=False, initExag=10.0, 
		finalExag=1.0, ppl=0.1, repeats=1):
	pTable = AssertProteinTable()	
	dt = cs.VectorizeProtein1(ALPHABET, 100, idList, pTable)
	for k, b in enumerate(vv.Dataset.BodyListForId(idList)):
		dt.RowSpecList[k].CopyFromBody(b)
	mds = NewMds(dt, epochs=epochs, is3D=is3D, initExag=initExag, finalExag=finalExag, ppl=ppl)
	info = MapInfo().Init(epochs, is3D, initExag, finalExag, ppl)
	info.Mtd = 'PmAA'
	RunMds(mds, repeats=repeats, info=info)
	if repeats>=1:
		mds.Close()

#-----------------------------------------------------------------------------


def ShowSeqInfo(pId, showSeq=False, showTable=False, barView=False, useAApair=True, markovTrans=False):
	ds = vv.Dataset
	rIdx = ds.IndexOfRow(pId)
	pSeq = ds.GetDataAt(rIdx, 2)
	pGene = ds.BodyList[rIdx].Name			
	pLen = int(ds.GetDataAt(rIdx, 3))
	ppList = [a+b for a in P for b in P] if useAApair else list(ALPHABET)
	sTitle = f'Protein: {pGene}, {pId}, L:{pLen}'
	if showSeq:
		tp = New.TextPanel(sTitle, pSeq)
		tp.Show()
	if showTable:
		maxWaveLen = 1000 if useAApair else 100
		nt = cs.ToWaveTable(pSeq, ppList, maxWaveLen)
		for rs in nt.RowSpecList:
			rs.Type = P[rs.Id[0]]
		hm = nt.ShowHeatMap()
		hm.Title = sTitle
		hm.SpectrumType = 4
		hm.ColorPaletteName = 'rP8'
		hm.ScrollingSteps = 1
		hm.BaseLineType = 0
		hm.SpectrumType = 4
		hm.ReadOnly = True
		hm.Redraw()
	if barView:
		bv = New.BarView(pLen)
		for k, item in enumerate(bv.ItemList):
			item.Group = P[pSeq[k]]
			item.Value = 1.0
		bv.Horizontal = False
		bv.BarLabelType = 0
		bv.HighlightColor = New.Color('White')
		bv.Show()
		bv.Tag = (pSeq, 0, ppList)
		bv.SetMouseWheelHandler('@FilterSq2(vv.EventSource.Form)')
		bv.AutoScaling = True
		bv.ReadOnly = True
		if showTable:
			hm.Tag = bv
			hm.AddEventHandler('ItemsSelected', '@SetFilterIdx()')
		bv.Title = sTitle
	if markovTrans:
		nt = New.NumberTable(cs.MarkovianMatrix0(pSeq))
		for k, rs in enumerate(nt.RowSpecList):
			rs.Id = ALPHABET[k]
			rs.Type = k
			nt.ColumnSpecList[k].Type = k
			nt.ColumnSpecList[k].Id = rs.Id
		bb = New.BarBand(nt)
		bb.UsingColorPalette = True
		bb.AutoScaling = True
		bb.AttributeMode = False
		bb.Title = sTitle
		bb.Show()

def ShowWeb(pId):
	if vv.Dataset.ColumnSpecList[0].Id == 'PID':
		pId = pId[:4]
		vv.StartProcess(f'https://rcsb.org/3d-view/{pId}')
	else:
		vv.StartProcess(f'https://www.ncbi.nlm.nih.gov/protein/{pId}')

def ShowMainChain(pMap):
	bList = pMap.BodyList
	mchName = bList[0].Name.split('.')[2]
	pMap.SelectedItems = [b.Id for b in bList if b.Name.split('.')[2] == mchName]
	pp.ClickMenu('3D Animation View...')
	vv.LastView.NormalizeView()

def ShowChimeraX(pId):
	localPath = Download3DInfo(pId[:4])
	progPath = "C:\\Program Files\\ChimeraX 1.9.dev202408012149\\bin\\ChimeraX.exe"
	vv.StartProcess(progPath, localPath)

def UpdateBv(bv, pSeq, filterIdx, filterList):
		bv.Tag = (pSeq, filterIdx, filterList)
		a2 = filterList[filterIdx]
		for k, item in enumerate(bv.ItemList):
			item.Value = 1.0 if pSeq[k:k+2].startswith(a2) else 0.0
		bv.Title = f'AA key: #{filterIdx}:{a2} of {len(filterList)}'
		bv.Redraw()

def SetFilterIdx():
	if vv.EventSource.Item.Name == 'HeatMap':
		hm = pp
		if hm.SelectionMode != 0 : return
		if hm.SelectedItems.Count == 0: return
		bv = hm.Tag
		(pSeq, filterIdx, filterList) = bv.Tag
		filterIdx = filterList.index(hm.SelectedItems[0])
		UpdateBv(bv, pSeq, filterIdx, filterList)

def FilterSq2(bv):
	(pSeq, filterIdx, filterList) = bv.Tag
	L = len(filterList)
	filterIdx = (filterIdx + vv.EventSource.Argument + L) % L
	UpdateBv(bv, pSeq, filterIdx, filterList)
	vv.SelectedItems = [ filterList[filterIdx] ]

#-----------------------------------------------------------------------------

def NewDataset1(P, pSeq, decay):
	L = len(P)
	hv = np.zeros((L))  # head-vector.
	stepSz = np.ones((L))
	dt = np.zeros([len(pSeq), len(P)], np.float32)
	for k, c in enumerate(pSeq):
		hv += stepSz
		hv[P[c]] = 0
		dt[k] = hv
	dt = np.reciprocal(decay+dt)
	for k in range(1, dt.shape[0]):
		dt[k, :] = 0.8*dt[k-1] + 0.2*dt[k]
	return dt

def NewDataset0(P, pSeq, winSize=0):
	pSeq = FilterSeq(pSeq, P)
	if winSize == 0: 
		winSize = int(6.086+0.015652*len(pSeq))
		winSize = max(5, int(0.5*winSize))
	ww = [1.0 - k/winSize for k in range(winSize)]  # window weights
	W, L = len(ww), len(pSeq)
	dt = np.zeros([len(pSeq), len(P)], np.float32)
	for row, c in enumerate(pSeq):
		col0 = P[c]
		W0 = -W+1  # symmetric window
		for w in range(W0, W):
			row_w = row + w
			if row_w < 0 or row_w >= L:
				continue
			col = P[pSeq[row_w]]
			dt[row, col] += ww[abs(w)]	
	return dt

def AugmentData(nt, augCfg='a|400|0.02|0.02'):
	fs = augCfg.split('|')
	N = nt.shape[0]
	match fs[0][0]:
		case 'a': # spiral augmentation
			nC = int(fs[1])   # point-per-circle
			R  = float(fs[2]) # radius of circle
			sC = float(fs[3]) # width of circle
			phase = float(fs[4]) if len(fs)==5 else 0
			a = 2.0*math.pi/nC  # angular speed
			sX = sC/nC  # speed in X direction.
			A = np.zeros((N, 3), np.float32 )
			for n in range(N):
				A[n] = R*math.sin(n*a+phase), R*math.cos(n*a+phase), n*sX
		case 'b':  # simple linear augmentation
			sf = float(fs[1])/1000.0
			A = np.zeros((N, 1), np.float32 )
			for n in range(N):
				A[n] = sf * n
		case 'c':  # circle augmentation
			R = float(fs[1])
			A = np.zeros((N, 2), np.float32 )
			a = 2.0*math.pi/N
			phase = float(fs[2]) if len(fs)==3 else 0
			for n in range(N):
				A[n] = R*math.sin(n*a+phase), R*math.cos(n*a+phase)
		case 'm':
			mom = float(fs[1])
			g = 1.0 - mom
			for k in range(1, N):
				nt[k, :] = mom*nt[k-1, :] + g*nt[k, :]
			return nt
		case 'M':
			nt2 = np.copy(nt)
			mom = float(fs[1])
			g = 1.0 - mom
			for k in range(1, N):
				nt[k, :] = mom*nt[k-1, :] + g*nt[k, :]
			mom = float(fs[2])
			nt = mom*nt + (1-mom)*nt2			
			return nt
		case 's':
			A = np.zeros((N, 2), np.float32 )
			n0 = int(fs[1])   # number of points in the first ring.
			R = float(fs[2])  # the radius of the first ring 
			G = float(fs[3])  # the gape size relative to R
			a, r = 0, R
			for k in range(N):
				A[k] = r*math.cos(a), r*math.sin(a)
				n = n0*r/R
				r += R*G/n
				a += 2*math.pi/n					
		case 'x':
			return nt
	return np.hstack((nt, A))


def NewDataset(S, winSize=0, decay=1.0, alphbetList=ALPHABET, augCfg='a|500|2.0|2.0'):
	P = {a:k for k,a in enumerate(alphbetList)}
	if winSize>= 0:
		dt = AugmentData(NewDataset0(P, S, winSize), augCfg)
	else:
		dt = AugmentData(NewDataset1(P, S, decay=decay), augCfg)
	nt = mm.ToTable(dt)
	for k, c in enumerate(S):
		nt.RowSpecList[k].Name = c
		nt.RowSpecList[k].Type = P[c]
	for col in range(len(P)):
		nt.ColumnSpecList[col].Id = alphbetList[col]
	return nt

#-----------------------------------------------------------------------------

def NewMds(nt, epochs=10000, is3D=False, initExag=10.0, finalExag=1.0, ppl=0.1, 
		repeats=1, metric='EuclideanMetric', glyphSet=None):
	mds = New.MdsCluster(nt)
	mds.Show()
	mds.MdsAlgorithm = 2
	mds.MaxLoops = epochs
	mds.RefreshFreq = 50
	mds.InitialExaggeration = initExag
	mds.FinalExaggeration = finalExag
	mds.PerplexityRatio = ppl
	mds.Metric = metric
	mds.Repeats = repeats
	mds.ReadOnly = True
	mds.Is3D = is3D
	mds.AutoNormalizing =True
	mds.GlyphOpacity = 0.5
	mds.GlyphSize = 0.5
	#mds.GlyphSet = 'C12|||||||||||'
	mds.GlyphSet = vv.Map.GlyphType if glyphSet==None else glyphSet
	return mds

def RunMds(mds, repeats=1, glyphSize=0.5, glyphOpacity=0.5, info=None):
	if info is not None:
		info.DDM = mds.DataDim
	mds.Description = info.ToStr() if info is not None else 'Map created by RunMds'
	mds.Repeats = repeats
	mds.Reset().Start()
	mds.GlyphOpacity = glyphOpacity
	mds.GlyphSize = glyphSize
	if not mds.Completed: 
		vv.Return(0)
	if repeats == 1:
		mds.ShowSnapshot()
	return mds

#-------------------------------------------------------------------

def ShowMapData(pMap):
	pSeq = ''.join([b.Name for b in pMap.BodyList]).upper()	
	info = MapInfo(pMap.Description)
	if info.Mtd == 'PDB':
		nt = New.NumberTable(pp.BodyListEnabled(), 3)
	else:
		winSize = int(info.WinSize) if info.WinSize != None else 0
		nt = NewDataset(pSeq, winSize=winSize, augCfg=info.AugCfg)
	nt.ShowHeatMap().NormalizeView()

def CreateSeqMaps(pList, epochs=10000, winSize=0, decay=1.0, repeats=1, saveTo=None, glyphSize=0.8, ppl=0.05,
		glyphOpacity=0.5, is3D=False, initExag=10.0, finalExag=1.0, augCfg='a|500|2.0|2.0'):
	if len(pList) <= 0:
		vv.Message("No protein group selected")
		vv.Return(0)
	pTable = AssertProteinTable()
	mds = NewMds(None, epochs=epochs, is3D=is3D, initExag=initExag, finalExag=finalExag, ppl=ppl)
	mds.GlyphSet = '36 Clusters'
	info = MapInfo().Init(epochs, is3D, initExag, finalExag, ppl)
	info.WinSize = winSize	
	info.AugCfg = augCfg
	info.Mtd = 'Frg'
	info.DS = vv.Dataset.Name
	mapSore = NewMapStore(saveTo, is3D)
	for k, pId in enumerate(pList):
		pSeq = GetProteinSeq(pTable, pId)
		if pSeq is None:
			vv.Message("Cannot get protein seq of: " + pId)
			vv.Return()
		nt = NewDataset(pSeq, winSize=winSize, decay=decay, augCfg=augCfg)
		SeqLabeling(nt, pSeq)
		mds.SetTrainingData(nt)
		RunMds(mds, repeats=repeats, glyphSize=glyphSize, glyphOpacity=glyphOpacity, info=info)
		info.pId = pId
		info.pLen = len(pSeq)
		map = vv.LastView
		map.Title = f'{k}: {pId}, N: {nt.Rows}'
		map.Description = info.ToStr()
		if mapStore is not None:
			mapStore.AddMaps()
	if repeats > 0:
		mds.Close()
	if mapStore != None: 
		mapStore.Close()

def Scanning(pMap, stride=100, stepSize=20):
	bsList = [b.Id for b in pMap.BodyList]
	for rp in [0,1]:
		for k in range(0, len(bsList), stepSize):
			pp.SelectedItems = bsList[k:k+stride]
			vv.Sleep(20)
			if pMap.SelectedItems.Count == 0: return
		vv.Sleep(1000)

def NewDatasetMkv(tm, pSeq, augCfg):
	#tmT = mm.ToNumpy(vv.AtlasManager.ReadNumberTable('TestMaps', 'MkvTransT'))
	#tm = np.concatenate((tm, tmT), axis=1)

	L = len(pSeq)
	nt = np.zeros((L, tm.shape[1]), np.float64)
	for n in range(L):
		nt[n] = tm[ P[pSeq[n]] ]
	nt = AugmentData(nt, augCfg)
	dt = mm.ToTable(nt)
	return dt

def SeqLabeling(dt, pSeq):
	aaIdx, aaNr = {}, {ch:0 for ch in ALPHABET}
	for n, rs in enumerate(dt.RowSpecList):
		ch = pSeq[n]
		rs.Name, rs.Type = ch, P[ch]
		if ch not in aaIdx:
			rs.ShowName = True
		aaIdx[ch] = n
		rs.Id = ch + str(aaNr[ch])
		aaNr[ch] += 1
	for n in aaIdx.values():
		rs = dt.RowSpecList[n]
		rs.ShowName = True
		rs.Name = rs.Name.lower()


def SeqMapByMarkovian(pList, epochs=10000, repeats=1, saveTo=None, glyphSize=0.8, ppl=0.05,
		glyphOpacity=0.5, is3D=False, initExag=10.0, finalExag=1.0, augCfg='a|500|2.0|2.0'):
	tm = mm.ToNumpy(vv.AtlasManager.ReadNumberTable('TestMaps', 'MkvTrans'))

	if len(pList) <= 0:
		vv.Message("No protein group selected")
		vv.Return(0)
	pTable = vv.Dataset
	mds = NewMds(None, epochs=epochs, is3D=is3D, initExag=initExag, finalExag=finalExag, ppl=ppl)
	mds.GlyphSet = '36 Clusters'
	mds.GlyphSize = glyphSize
	mds.GlyphOpacity = glyphOpacity

	info = MapInfo().Init(epochs, is3D, initExag, finalExag, ppl)
	info.AugCfg = augCfg
	info.Mtd = 'Mkv'
	mapStore = NewMapStore(saveTo, is3D)
	for k, pId in enumerate(pList):
		pSeq = GetProteinSeq(pTable, pId)
		if pSeq is None:
			vv.Message("Cannot get aa-seq of: " + pId)
			continue
		nt = NewDatasetMkv(tm, pSeq, augCfg)
		SeqLabeling(nt, pSeq)
		mds.SetTrainingData(nt)
		info.pId = pId
		info.pLen = len(pSeq)
		info.DS = pTable.Name
		RunMds(mds, repeats=repeats, glyphSize=glyphSize, glyphOpacity=glyphOpacity, info=info)
		map = vv.LastView
		map.Title = f'{k}: {pId}, N: {nt.Rows}'
		if mapStore != None: mapStore.AddMaps()
	if mapStore != None: mapStore.Close()
	if repeats > 0:
		mds.Close()

#-------------------------------------------------------------------

def ShowAASeq(pMap):
	info = MapInfo(pMap.Description)
	if info.Mtd == 'PDB':
		pSeq = []
		chName = None
		for b in pMap.BodyList:
			if (b.Id[0] == 'A') and (b.Name[0] in P):
				if chName == None:
					chName = b.Name.split('.')[2]
				if b.Name.split('.')[2] == chName:
					pSeq.append(b.Name[0])		
		pSeq = ''.join(pSeq)
		tp = New.TextPanel(f'Protein: {info.pId}, {len(pSeq)}', pSeq)
		tp.Show()
	else:
		pSeq = ''.join([b.Name for b in pMap.BodyList]).upper()
		tp = New.TextPanel(f'Protein: {info.pId}, {len(pSeq)}', pSeq)
		tp.Tag = pMap
		tp.OnSelection = '@OnSeqSelection()'
		pMap.AddEventHandler('ItemsSelected', '@OnSeqSelected()')
		bId2Idx = {pMap.BodyList[k].Id:k for k in range(pMap.BodyList.Count)}
		pMap.Tag = (tp, bId2Idx)
		tp.Show()

def OnSeqSelection():
	pMap = pp.Tag
	if pMap.TheForm.IsDisposed or not vv.MouseButtons.LeftButtonPressed:
		return
	tb = pp.TextBox
	iBegin = tb.SelectionStart
	iEnd = tb.SelectionStart + tb.SelectionLength
	bsList = pMap.BodyList
	pMap.SelectedItems = [bsList[k].Id for k in range(iBegin, iEnd)]

def MarkSeq(tb, idxBegin, idxEnd):
	if idxEnd<=idxBegin: 
		return
	tb.Select(idxBegin, idxEnd-idxBegin)
	tb.SelectionBackColor = New.Color('Skyblue')	

def OnSeqSelected():
	(tp, bId2Idx) = pp.Tag	
	if tp.TheForm.IsDisposed: 
		return
	L = sorted( [bId2Idx[id] for id in pp.SelectedItems] )
	tb = tp.TextBox
	tb.SelectAll()
	tb.SelectionBackColor = tb.BackColor	
	tb.SelectionLength = 0
	N = len(L)
	i = 0
	while i < N:
		j = i+1
		while j < N:
			if L[j] - L[j-1] > 1:
				MarkSeq(tb, L[i], L[j-1]+1)
				break
			else:
				j += 1
		if j == N:
			MarkSeq(tb, L[i], L[j-1]+1)
		i = j

def ShowProteinSeq(pMap):
	pId = pMap.SelectedItems[0]
	rowIdx = vv.Dataset.IndexOfRow(pId)
	pSeq = vv.Dataset.GetDataAt(rowIdx, 2)
	pSym = vv.Dataset.GetDataAt(rowIdx, 1)
	pLen = int(vv.Dataset.GetDataAt(rowIdx, 3))
	tb = New.TextPanel(f'{pId}: {pSym}, {pLen}', pSeq)
	tb.Show()

def ConfigAtlasMaps(atlas, mpWidth=1000, mpHeight=700, gSize=0.35, gOpacity=0.5, hiddenSize=7, reset=False):
	itemList = atlas.GetSelectedItems()
	for it in itemList:
		mp = it.Open()
		if reset:
			for b in mp.BodyListEnabled():
				b.Type = 0
				b.Hidden = False
				b.ShowName = False
		mp.GlyphSize = gSize
		mp.GlyphOpacity = gOpacity
		mp.HiddenBodySize = hiddenSize
		mp.NameLabelColor = New.Color('Yellow')
		mp.NameLabelFont = New.Font('Microsoft Sans Serif', 18.0)
		mp.Resize(0,0,mpWidth,mpHeight)
		#mp.NormalizeView()
		info = MapInfo(mp.Description)
		it.LabelStyle = 2
		it.Name = info.pId
		mp.Close()

def ReCreateMap(pMap):
	pSeq = ''.join([b.Name for b in pMap.BodyList]).upper()	
	info = MapInfo(pMap.Description)
	if info.Mtd == 'Mkv':
		tm = mm.ToNumpy(vv.AtlasManager.ReadNumberTable('TestMaps', 'MkvTrans'))
		nt = NewDatasetMkv(tm, pSeq, augCfg=info.AugCfg)
	else:
		nt = NewDataset(pSeq, winSize=int(info.WinSize), augCfg=info.AugCfg)

	for k, b in enumerate(pMap.BodyList):
		nt.RowSpecList[k].CopyFromBody(b)

	mds = NewMds(nt, epochs=int(info.Epochs), is3D=eval(info.Is3D), 
		initExag=float(info.InitE), finalExag=float(info.FinalE), ppl=float(info.PP))
	mds.GlyphSet = pMap.GlyphSet
	mds.GlyphSize = pMap.GlyphSize
	mds.GlyphOpacity = pMap.GlyphOpacity
	RunMds(mds, info=info)
	mds.Close()


def SmoothenCurve(pMap, repeats):
	bsList = [b for b in pMap.BodyListEnabled() if b.Id[0] != 'H']
	for n in range(repeats):
		cs.SmoothenBodyList(bsList)
	pMap.RedrawAll()

def UnfoldAtlasMaps(atlas, mapItems, atName=None, stretch=0, contractFactor=1.0):
	mapStore = NewMapStore(atName, False)
	for k, m in enumerate(mapItems):
		mp = m.Open()
		mp.TheForm.Hide()
		atlas.SetSelectedItems([m])
		UnFoldMap(mp, epochs=1000, repeats=1, is3D=False,
			finalExag=1.0, ppl=0.1, stretch=stretch, contractFactor=contractFactor)
		mp.Close()
		if mapStore != None:
			mapStore.AddMaps()
	if mapStore != None:
		ma = mapStore.atlas
		ma.Width = atlas.Width
		ma.ArrangeItems()
		ma.TheForm.Show()

cs2 = New.CsObject('''
public IList<string> SelectByAA(IList<IBody> bList, string pAA) {
	return bList.Where(b=>pAA.Contains(b.Name[0])).Select(b=>b.Id).ToList();
}
''')

def ScanningForAA(pMap, pAA, progressive=False):
	aaList = cs2.SelectByAA(pMap.BodyList, pAA)
	L = aaList.Count
	pMap.Title = f'Amino Acide: {pAA}: {int(L/8)}'
	if progressive:
		stride = 1 + int(L/500)
		for n in range(1, L, stride):
			pMap.SelectedItems = aaList.GetRange(0, n)
	else:
		pMap.SelectedItems = aaList


'''

pp.GlyphOpacity = 0.125

ScanningForAA(pp, 'S')  #S|T|C|STC			# Necleophilic
ScanningForAA(pp, 'VLIMP')  #V|L|I|M|P|VLIMP		# Hydrophobic
ScanningForAA(pp, 'FYW')  #F|Y|W|FYW	  # Aromatic
ScanningForAA(pp, 'DE')  #D|E|DE       # Acidic
ScanningForAA(pp, 'N')  #N|Q|NQ       # Amide
ScanningForAA(pp, 'HKR')  #H|K|R|HKR    # Basic
ScanningForAA(pp, 'GA', True)  #G|A|GA    # Small AA
ScanningForAA(pp, 'M')  #A|R|N|D|C|E|Q|G|H|I|L|K|M|F|P|S|T|W|Y|V
ScanningForAA(pp, 'H') #H|W|HW		# 2 forms 'bound' 1EK9

ScanningForAA(pp, 'L')  #A|V|I|L|M|F|Y|W|AVILMFYW		# Hydrophobic
ScanningForAA(pp, 'STNQ')  #S|T|N|Q|STNQ		# Polar Uncharged
ScanningForAA(pp, 'P')  #C|G|P|CGP         # Special Cases
ScanningForAA(pp, 'DE')    #R|H|K|RHK|D|E|DE  # Positive (3) and Negative (2) changed.

for aa in 3*['AVILMFYW', 'STNQ', 'CGP', 'RHK', 'DE']:
	ScanningForAA(pp, aa)
	vv.Sleep(1000)

import os
fs = [f[:4] for f in os.listdir('c:\\temp') if f.endswith('.cif') ]
mapStore = NewMapStore('All Proteins', True)
for k, pId in enumerate(fs):
	try:
		ShowPDB(pId, rp=3, eps=0.1, includeHA=True)
	except Exception as err:
		print(f'Failed to load {pId}: {err}')
		continue
	mapStore.AddMaps()



'''
