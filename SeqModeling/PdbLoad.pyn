
def ShowPDB(pId, rp=3, eps=0.1, includeHA=True):
	localPath, bsList, bsList2, pdbTitle = LoadCifData(pId[:4])
	bsList = Interporlate(bsList, rp, eps)
	if includeHA:
		bsList.AddRange(bsList2)
	mp = New.Map3DView(bsList)
	info = MapInfo()
	info.pId = pId
	info.pLen = bsList.Count
	info.Mtd = 'PDB'
	info.PT = pdbTitle
	mp.Description = info.ToStr()
	mp.Title = f'{pId}: Len:{bsList.Count}'
	mp.GlyphSet = '36 Clusters||Colored Balls'
	mp.ReadOnly = True
	mp.ShowPerformance = False
	mp.ShowBoundingBox = False
	mp.GlyphSize = 0.75
	mp.GlyphOpacity = 0.5
	mp.Show()
	mp.NormalizeView()

def GetString(L, fPDB):
	idx = L.find('\'')
	if idx < 0:
		L = fPDB.readline()
		if L[0] == ';':
			return L[1:].strip()
		elif L[0] == '\'':
			return L.strip().strip('\'')
		else:
			return ''
	s = L[idx:].strip().strip('\'')
	s = s.replace(':', '..')
	s = s.replace(';', '.,')
	return s

def LoadCifData(prName):
	localPath = Download3DInfo(prName)
	try:
		bsList, bsList2 = New.BodyList(), New.BodyList()
		betaSet, helixSet = set(), set()
		pdbTitle = ''
		with open(localPath) as fPDB:
			L = fPDB.readline()
			if not L.startswith('data_'):
				vv.Message('Invalid header-line: ' + L)
				vv.Return()
			for L in fPDB:
				if L.startswith('_struct_sheet_range.end_auth_seq_id'):
					betaSet = LoadBetaSheet(fPDB)
				elif L.startswith('_struct_conf.pdbx_PDB_helix_length'):
					helixSet = LoadHelix(fPDB)
				elif L.startswith('_struct.title'):
					pdbTitle = GetString(L, fPDB)					
				elif L.startswith('_atom_site.pdbx_PDB_model_num'):
					bsList, bsList2 = LoadAtoms(fPDB, helixSet, betaSet)
					break	
	except Exception as err:
		print(err, f'Last Line:\n {bsList.Count}: |{L}|')

	if bsList.Count == 0:
		vv.Message('No amino-acids found!')
		vv.Return()
	return localPath, bsList, bsList2, pdbTitle


def OpenPDBFile(pMap):
	info = MapInfo(pMap.Description)
	OpenCifFile(info.pId)

def OpenCifFile(pId):
	pId = pId[:4]
	pdbPath = f'C:/temp/{pId}.cif'
	vv.StartProcess("vi", f'C:/temp/{pId}.cif')

def AugmentByIndex(nt, stretch):
	nt.AddColumns(1)
	M = nt.Matrix
	rsList = nt.RowSpecList
	# get the number of interpolation points which is normally 8
	for ipp in range(1, 128):  
		if rsList[ipp].Id[0] == 'A':
			break
	dx = 0.01*stretch/ipp
	offset = 0	
	for row, rs in enumerate(rsList):
		# hetero atoms don't participate in the unfold stretching
		if rs.Id[0] == 'H': continue
		M[row][3] += offset
		offset += dx
	return nt

def Download3DInfo(pId):
	from os.path import exists
	from urllib.request import urlretrieve
	fileName = pId + '.cif'
	localPath = 'c:/temp/' + fileName
	if not exists(localPath):
		urlretrieve(f'https://files.rcsb.org/download/{fileName}', localPath)
	return localPath

class ChainIndex():
	def __init__(self):
		self.chain2Index = {'HOH':(72+3), 'NAG':(72+11)}
		self.headIndex = 0
	def Lookup(self, chName):
		if chName not in self.chain2Index:
			for k in range(self.headIndex, 200, 1):
				if k not in self.chain2Index.values():
					self.chain2Index[chName] = k
					self.headIndex = k+1
					break
			if chName not in self.chain2Index:
				self.chain2Index[chName] = 200
		return self.chain2Index[chName]
	def Contains(self, chName):
		return chName in self.chain2Index

def CheckForPDB(pMap):
	info = MapInfo(pMap.Description)
	if info.Mtd != 'PDB':
		vv.Message('The parent map is not created from PDB file')
		vv.Return()

def HideInterpolates():
	for b in pp.BodyList:
		if b.Id.startswith('i'):
			b.Hidden = True
	pp.TheForm.HiddenBodySize = 4
	pp.RedrawAll()

def ShowHelix():
	vv.SelectedItems = [b.Id for b in pp.BodyList if b.Name.endswith('.h')]

def ShowBetaSheet():
	vv.SelectedItems = [b.Id for b in pp.BodyList if b.Name.endswith('.b')]

def LoadBetaSheet(fPDB):
	betaSet = set()
	for L in fPDB:
		if L[0] == '#': break
		fs = L.split()
		idx0 = int(fs[4]) - 1
		idx1 = int(fs[8]) + 1
		for i in range(idx0, idx1):
			betaSet.add(i)
	return betaSet		

def LoadHelix(fPDB):
	helixSet = set()
	for L in fPDB:
		if not L.startswith('HELX_P'): break
		fs = L.split()
		idx0 = int(fs[5])
		idx1 = int(fs[9]) + 1
		for i in range(idx0, idx1):
			helixSet.add(i)
	return helixSet

def LoadAtoms(fPDB, helixSet, betaSet):
	bsList = New.BodyList()
	bsList2 = New.BodyList() # for hetero atoms
	ch2idx = ChainIndex()
	for L in fPDB:
		if L[0] == '#':
			break
		if L[0] == '_':
			continue
		fs = L.split()
		if len(fs) < 21:
			vv.Message(f'Invalid record: {len(fs)}: |{L}|')
			vv.Return()		
		
		rsX, rsY, rsZ = float(fs[10]), float(fs[11]), -float(fs[12])	
		atName = fs[3].strip('\"')
		rsName = fs[5]
		chName = fs[6] + '_' + fs[20]
		secType = 'x'  # default secondary type

		if fs[0] == 'ATOM':
			rsIdx = int(fs[8]) - 1
			# Set p1 which is either a capital for an AA type; or 'r' for RNA peptide; 
			# or 'd' for DNA peptide; or 'x' for unknow elements.
			if (rsName in P3) and ( (atName=='CA') or (atName=='C2') ):
				p1 = P3[rsName]  # amino acid polymers.
				if rsIdx in helixSet:
					secType = 'h'
				elif rsIdx in betaSet:
					secType = 'b'
			elif (rsName in 'AUGC') and (atName=="C1'"):
				p1 = 'r'   # RNA polymers
			elif (rsName in ['DA', 'DT', 'DG', 'DC'] ) and (atName=="C1'"):
				p1 = 'd'   # DNA fragments
			else:
				continue
			bId = f'A{rsIdx}.{bsList.Count}'
		elif fs[0] == 'HETATM':
			bId = f'H.{fs[3]}.{bsList2.Count}'
			p1 = fs[3]
		else:
			continue	

		b = New.Body(bId)
		b.X, b.Y, b.Z = rsX, rsY, rsZ

		b.Name = p1 + '.' + rsName + '.' + chName + '.' + secType
		b.Type = ch2idx.Lookup(chName)
		
		if b.Id[0] == 'H':  # for heter-atoms
			if ch2idx.Contains(rsName):
				b.Type = ch2idx.Lookup(rsName)
			else:
				b.Type = 72+25
			bsList2.Add(b)
		else:
			if b.Name[0] in ['r', 'd']:
				b.Hidden = True
			bsList.Add(b)	
	return bsList, bsList2


def Interporlate(bsList, rp, eps):
	bs = New.BodyList()
	k0 = 0
	t0 = bsList[k0].Type
	for k in range(bsList.Count+1):
		if (k == bsList.Count) or (bsList[k].Type != t0):
			D = cs.Interpolate3D(bsList.GetRange(k0, k-k0), rp, eps, bs.Count)
			bs.AddRange(D)
			if k < bsList.Count:
				k0 = k
				t0 = bsList[k0].Type
	return bs

def UnFoldMap(pMap, epochs=1000, ppl=0.1, repeats=1, stretch=0, contractFactor=1.0, initExag=10.0, finalExag=1.0, is3D=False):
	bList = pMap.BodyListEnabled()
	if contractFactor != 1.0:
		bList = New.BodyListClone(bList)
		bList = cs.ClusterContract(bList, contractFactor)
	nt = New.NumberTable(bList,3)
	if stretch != 0:
		AugmentByIndex(nt, stretch=stretch)
	mds = NewMds(nt, is3D=is3D, glyphSet=pMap.GlyphSet, initExag=initExag, finalExag=finalExag,
		epochs=epochs, ppl=ppl)
	info = MapInfo(pMap.Description).SetMds(mds)
	info.SF = stretch
	info.CF = contractFactor
	winTitle = pMap.Title
	RunMds(mds, repeats=repeats, glyphSize=0.5, info=info)
	vv.LastView.Title = winTitle
	mds.Close()

def UnFoldMap2(pMap, epochs=1000, ppl=0.1, initExag=10.0, finalExag=1.0):
	nt = New.NumberTable(pMap.BodyListEnabled(),3)
	mds = NewMds(nt, glyphSet=pMap.GlyphSet, initExag=initExag, finalExag=finalExag,
		epochs=epochs, ppl=ppl)
	info = MapInfo(pMap.Description).SetMds(mds)
	RunMds(mds, info=info)
	nt2 = New.NumberTable(mds.BodyList, 2)
	mds.MaxLoops = epochs
	mds.SetTrainingData(nt.AppendColumns(nt2))
	RunMds(mds, info=info)
	mds.Close()


