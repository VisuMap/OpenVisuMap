# VsMap.pyn
#
# Train a model to the current map together with its clustering.
#
#------------------------------------------------------------------------
vv.Import('CommonUtil.pyn')
vv.Import('VsModelling.pyn')
InitVmd()
vmd.Clear()

Ym = GetMapData()
Yc = GetClusterData()
X = GetDatasetData()
Y = tf.concat([Ym, Yc], axis=1)
vmd.ds = TrainDataset(X, Y)
dimList, DropR, LR, epochs  = [128, 64, 32], 0.5, 0.001, 1000
mapDim = Ym.shape[1]

class FullMapLoss():
	def __init__(self, mapDim):
		self.mapDim = mapDim
		self.MSE = keras.losses.MeanSquaredError()
		self.Entropy = keras.losses.CategoricalCrossentropy()
	def __call__(self, Y, pY):
		mD = self.mapDim
		return self.MSE(Y[:,:mD], pY[:,:mD]) + self.Entropy(Y[:, mD:], pY[:, mD:])

class MapOutLayer(keras.layers.Layer):
	def __init__(self, Y, mapDim, clusterDim):
		super(MapOutLayer, self).__init__()
		self.mapFct = DenseLayer(mapDim, 'sigmoid')
		self.clusterFct = DenseLayer(clusterDim, 'leaky_relu')
		self.Softmax = keras.layers.Softmax(name='Softmax')
		Ym = Y[:,:mapDim]
		colMin, colMax = np.min(Ym, axis=0), np.max(Ym, axis=0) 
		self.colScale = colMax - colMin
		self.colShift = 0.5*(colMax + colMin - self.colScale)

	def call(self, X):		
		Ymap = self.colScale * self.mapFct(X) + self.colShift
		Ycluster = self.Softmax(self.clusterFct(X))
		return tf.concat([Ymap, Ycluster], axis=1)

def NewFullModel(layerDims, X, Y, mapDim, dropoutRatio=0.25):
	md = keras.Sequential()
	md.add( keras.Input(shape=(X.shape[1])) )
	md.add( InScaling(X) )
	for k, dim in enumerate(layerDims):
		md.add( DenseLayer(dim, 'leaky_relu') )
		if (k == 0) and (dropoutRatio>0): 
			md.add(keras.layers.Dropout(dropoutRatio))
	md.add( MapOutLayer(Y, mapDim, Y.shape[1] - mapDim) )
	md.modelType = vmd.FULL_MODEL
	md.lossFct = FullMapLoss(mapDim)
	md.mapDim = mapDim
	return md

def Logger(epoch, cost):
	vmd.OpenLogMap()
	mD = vmd.model.mapDim		
	P = vmd.model(vmd.ds.X, training=False).numpy()
	vmd.logMap.MoveBodiesTo(mm.ToMatrix32(P[:,:mD]))
	err = np.mean(np.linalg.norm(vmd.ds.Y[:, :mD]-P[:, :mD], axis=1))
	misses = 123
	vmd.logMap.Title = f'Epoch:{epoch+1}, Cost:{cost:.2f}, L2:{err:.2f}, MisMatches:{misses}'

vmd.model = NewFullModel(dimList, X, Y, mapDim, DropR)

TrainModel(vmd, epochs=epochs, initial_lr=LR, logCallback=Logger)

