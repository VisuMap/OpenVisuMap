#ModellingHelp.pyn
import numpy as np
import math
import torch
from torch import nn
from torch.utils.data import Dataset, DataLoader

class ModellingConfiguration:
	def __init__(self):
		self.device = 'cuda' if torch.cuda.is_available() else 'cpu'
		self.NN = None
		self.log = None
		self.epochs = 500
		self.trainingTime = 0
		self.reportFreq = 50
		self.stopTraining = False

	def EnableLog(self):
		if (self.log == None) or self.log.TheForm.IsDisposed:
		    self.log = New.HistoryView().Show()

class MapDataset(Dataset):
	def __init__(self):
		self.X,  self.Y  = GetTrainData()
		self.XX, self.YY = Np2T(self.X), Np2T(self.Y)
		self.Samples = self.X.shape[0]

	def __getitem__(self, index):
		return self.XX[index], self.YY[index]

	def __len__(self):
		return self.Samples

	def GetLoader(self, batch_size=64):
		return DataLoader(dataset=self, batch_size=batch_size, shuffle=True)


class NeuralNetwork(nn.Module):
    def __init__(self, dims):
        super(NeuralNetwork, self).__init__()
        self.model = nn.Sequential()
        for k in range(len(dims)-1):
            self.model.add_module('lay'+str(k), nn.Linear(dims[k], dims[k+1], bias=True))
            self.model.add_module('f'+str(k), nn.LeakyReLU())
        self.scalings = nn.Parameter(10.0*torch.ones([dims[-1]]).to(mdc.device), requires_grad=True)
        self.model.apply(init_weights)
        self = self.to(mdc.device)

    def forward(self, x):
        return self.model(x) * self.scalings


def GetTrainData():
	X = mm.ToNumpy( vv.GetNumberTableView(True) )
	N = X.shape[0]
	inDim = X.shape[1]
	outDim = vv.Map.Dimension
	bList = vv.Dataset.BodyListEnabled()
	Y = np.empty([N, outDim], dtype=np.float32)
	for n in range(N):
		b = bList[n]
		if outDim == 2:
			Y[n] = [b.X, b.Y]
		else:
			Y[n] = [b.X, b.Y, b.Z]
	return X, Y

def GetTestData():
	return mm.ToNumpy( vv.GetNumberTableView(True) )

def Np2T(A):
	return torch.from_numpy(A).float().to(mdc.device)

def T2Np(T):
	return T.detach().cpu().numpy()

def init_weights(m):
    if isinstance(m, nn.Linear):
        torch.nn.init.xavier_uniform_(m.weight)
        m.bias.data.fill_(0.01)

def ShowPred(NN, XX, refY):
	P = T2Np(NN(XX))
	map = New.MapSnapshot(True).Show()
	bsList = map.BodyList
	for i in range(bsList.Count):
		b = bsList[i]
		[b.X, b.Y] = P[i]
	if refY is not None:
		err = np.mean(np.linalg.norm(refY-P, axis=1))
		map.Title = 'Preication Map  L2 Error: %.2f, Time: %.1fs'%(err, mdc.trainingTime)
	else:
		map.Title = 'Predication Map'
	map.RedrawAll()

mdc = ModellingConfiguration()

