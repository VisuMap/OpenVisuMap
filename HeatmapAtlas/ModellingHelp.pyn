#ModellingHelp.pyn
import numpy as np
import math, time
import torch
from torch import nn
from torch.utils.data import Dataset, DataLoader


class ModellingConfiguration:
	def __init__(self):
		self.device = 'cuda' if torch.cuda.is_available() else 'cpu'
		self.NN = None
		self.log = None
		self.reportFreq = 50

	def EnableLog(self):
		if (self.log == None) or self.log.TheForm.IsDisposed:
		    self.log = New.HistoryView().Show()
		    self.log.OnClose('@mdc.NN.stopTraining=True')

class MapDataset(Dataset):
	def __init__(self):
		self.X,  self.Y  = GetTrainData()
		self.XX, self.YY = Np2T(self.X), Np2T(self.Y)
		self.Samples = self.X.shape[0]

	def __getitem__(self, index):
		return self.XX[index], self.YY[index]

	def __len__(self):
		return self.Samples

	def GetLoader(self, batch_size=64):
		return DataLoader(dataset=self, batch_size=batch_size, shuffle=True)


class NeuralNetwork(nn.Module):
    def __init__(self, dims, trainData=None):
        super(NeuralNetwork, self).__init__()
        self.model = nn.Sequential()
        L = len(dims)
        for k in range(L-1):
            self.model.add_module('lay%d'%k, nn.Linear(dims[k], dims[k+1], bias=True))
            if k == (L-2):
                self.model.add_module('f%d'%k, nn.Sigmoid())
            else:
                self.model.add_module('f%d'%k, nn.LeakyReLU())            
            if k == 0:
                self.model.add_module('dp%d'%k, nn.Dropout(p=0.25))
        if trainData is None:
            columnRange = torch.ones([dims[-1]])
        else:
            columnRange = torch.from_numpy( 1.25 * np.max(trainData.Y, axis=0) )
        self.scalings = nn.Parameter(columnRange.to(mdc.device), requires_grad=False)
        self.model.apply(init_weights)
        self.layerDimensions = dims
        self = self.to(mdc.device)
        self.trainingTime = 0
        self.stopTraining = False

    def forward(self, x):
        return self.model(x) * self.scalings

    def Train(self, mapDs, epochs):	
        batchDs = mapDs.GetLoader(batch_size=25)
        optimizer = torch.optim.Adagrad(self.parameters(), lr=0.005)
        loss_func = torch.nn.MSELoss()	
        self.stopTraining = False
        startTime = time.time()
        for t in range(epochs):
            cost = 0
            for bX, bY in batchDs:
                loss = loss_func(self(bX), bY)
                optimizer.zero_grad(set_to_none=False)
                loss.backward()
                optimizer.step()
                cost += loss.data.cpu().numpy()
                vv.Sleep(0)
            cost /= len(batchDs)
            if self.stopTraining:
                break
            if ((t+1)%mdc.reportFreq == 0):
                mdc.log.AddStep(float(cost))
                mdc.log.Title = 'Eochs: ' + str(t+1)
        self.trainingTime = time.time() - startTime

#========================================================================================================

def GetMapData():
    outDim = vv.Map.Dimension
    bList = vv.Dataset.BodyListEnabled()
    N = bList.Count
    Y = np.empty([N, outDim], dtype=np.float32)
    for n in range(N):
        b = bList[n]
        if outDim == 2:
            Y[n] = [b.X, b.Y]
        else:
            Y[n] = [b.X, b.Y, b.Z]
    return Y

def GetTrainData():
	return mm.ToNumpy(vv.GetNumberTableView(True)), GetMapData()

def GetTestData():
	return mm.ToNumpy( vv.GetNumberTableView(True) )

def Np2T(A):
	return torch.from_numpy(A).float().to(mdc.device)

def T2Np(T):
	return T.detach().cpu().numpy()

def init_weights(m):
    if isinstance(m, nn.Linear):
        torch.nn.init.xavier_uniform_(m.weight)
        m.bias.data.fill_(0.01)

def ShowPred(NN, XX, refY):
	P = T2Np(NN(XX))
	map = New.MapSnapshot(True)
	bsList = map.BodyList
	for i in range(bsList.Count):
		b = bsList[i]
		[b.X, b.Y] = P[i]
	if refY is not None:
		err = np.mean(np.linalg.norm(refY-P, axis=1))
		map.Title = 'Preication Map  L2 Error: %.2f, Time: %.1fs'%(err, mdc.NN.trainingTime)
	else:
		map.Title = 'Predication Map'
	map.Show()

#========================================================================================================

if 'mdc' not in globals():
  mdc = ModellingConfiguration()

