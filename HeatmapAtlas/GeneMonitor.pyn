import math
import numpy as np

mpWidth, mpHeight, thresholdLevel = 500, 350, 1.0

cs = New.CsObject('''
public IBody MeanPoint(IList<IBody> bList){
	if (bList.Count == 0) 
		return null;
	double x = 0;
	double y = 0;
	foreach(IBody b in bList) {
		x += b.X;
		y += b.Y;
	}
	x /= bList.Count;
	y /= bList.Count;
	x -= 35.0;
	y += 20.0;
	IBody mBody = null;
	double mDist = 1.0e10;
	foreach(IBody b in bList) {
		double d2 = (b.X - x)*(b.X - x) + (b.Y - y)*(b.Y - y);
		if (  d2 < mDist ) {
			mBody = b;
			mDist = d2;
		}
	}	
	return mBody;
}

public INumberTable Transform(INumberTable nt) {
	MT.Loop(0, nt.Rows, row=>{
		  double[] R = nt.Matrix[row] as double[];
        for(int col=0; col<nt.Columns; col++)
            //R[col] = Math.Sqrt( Math.Abs(Math.Exp(R[col]) - 1) );
				//R[col] = Math.Exp(R[col]) - 1.0;
				R[col] = Math.Log(1.0 + R[col]);
	});
	return nt;
}
''')

def ThresholdHi(vList):
	tHi = math.sqrt( np.average(np.square(vList)) )
	return thresholdLevel*tHi

def transform(nt):
	return nt
	#return cs.Transform(nt)

def NewTsne(epochs=1000, PP=0.05, EX=4.0, ex=1.0, repeats=1):
	mds = New.TsneMap()
	mds.MaxLoops = epochs
	mds.PerplexityRatio = PP
	mds.InitialExaggeration = EX
	mds.FinalExaggeration = ex
	mds.ExaggerationSmoothen = True
	mds.RefreshFreq = 50
	mds.Is3D = False
	mds.AutoNormalizing = True
	mds.AutoScaling = False
	mds.Repeats = repeats
	mds.ReadOnly = True
	mds.Show()
	return mds

def GetId2Sym():
	global fctId2Sym
	if 'fctId2Sym' in globals():
		return fctId2Sym
	gt = vv.Folder.ReadDataset('Gene Features')
	if gt != None:
		cIdx = gt.IndexOfColumn('Symbol')
		id2sym_dic = {gt.BodyList[row].Id : gt.GetDataAt(row, cIdx) for row in range(gt.Rows)}
		fctId2Sym = lambda id: id2sym_dic[id] if id in id2sym_dic else id
	else:
		fctId2Sym = lambda id: id
	return fctId2Sym

def ConfigBarView(bv, nt, map):
	bv.Horizontal = False
	bv.BarLabelType = 1
	bv.AutoScaling = False
	bv.LowerLimit = 0
	bv.UpperLimit = 0
	bv.BaseLineType = 0
	bv.TopMost = True
	items = bv.ItemList
	dynamicColor = True
	gt = vv.Folder.ReadDataset('Gene Features')
	info = InfoFromStr(map.Description)
	id2key = DominantGenes(info['DG']) if 'DG' in info else None
	id2sym = GetId2Sym()
	for k, item in enumerate(items): 
		key = id2key.Lookup(item.Id) + '  ' if id2key != None else ''
		item.Name = key + id2sym(item.Id)
	bv.ReadOnly = True
	bv.Show()
	bv.Resize(0, 0, 500, 500)
	vv.EventManager.OnItemsSelected(f'@OnSelected({dynamicColor})', bv, nt)	
	bv.AddContextMenu("Atlas/Gene Detail", "@ShowGeneDetails()")

def ConfigMarker(mk):
	mk.AnimationPause = 25
	mk.AnimationStepSize = 1
	mk.LoopPath = False
	mk.NoLooping = False
	mk.MarkerColor = New.Color('Yellow')
	mk.Left = 200
	mk.Top = 200
	mk.Width = 70
	mk.Height = 12
	mk.SpinningMarker()

def Config3DMap(m3d):
	m3d.ReadOnly = True
	m3d.Resize(0, 0, 1000, 800)
	m3d.GlyphOpacity = 0.5
	m3d.GlyphSize = 0.45
	m3d.ShowBoundingBox = True
	m3d.ShowPerformance = False
	m3d.BackgroundColor = New.Color(0,0,64)
	m3d.ResetView(4); 
	m3d.Show()
	vv.Sleep(1000)
	for p in [2,0,2]:	m3d.ResetView(p);	vv.Sleep(750)
	m3d.RotateXYZ(-0.025, 0, 0, 10, 40); vv.Sleep(750)
	m3d.RotateXYZ(0, 0.005, 0, int(2*math.pi/0.005), 15)

def StartMonitor(nt, map=None):
	if map == None: 
		map = vv.MapView
	ConfigBarView(New.BarView(nt.ColumnSpecList), nt, map)
	ConfigMarker(map.ShowMarker(True))


def OnSelected(dynamicColor):
	nt = vv.EventSource.Argument.SelectRowsById(vv.SelectedItems)
	bv = pp
	if nt.Rows==0:
		return
	nt.ColumnMean(bv.ItemList)
	vList = [item.Value for item in bv.ItemList]
	maxV = max(vList)
	maxV = max(maxV, 0.01)
	if vv.ModifierKeys.AltPressed or (pp.UpperLimit == 0):		
		pp.UpperLimit = 0.125*(2**(math.ceil(math.log2(maxV/0.125))))
	if dynamicColor:
		vLimit = ThresholdHi(vList)
		for item in bv.ItemList: 
			item.Group = 0 if item.Value > vLimit else 4
	bv.Redraw()

def StartTracing(idMon, map=None):
	nt = vv.GetNumberTableView(True).SelectColumnsById(idMon)
	nt = transform(nt)
	StartMonitor(nt, map)

def LoopList(gList, epochs=1000, PP=0.05, SS=100, EX=4.0, ex=1.0, ss=0, saveTo=None, repeats=1): 
	if type(gList) is not list: 
		gList = [ gList ]
	mds = NewTsne(epochs, PP, EX, ex, repeats)
	nt0 = vv.GetNumberTableView(True)
	for listName in gList:
		idList = vv.GroupManager.GetGroupLabels(listName)
		if idList == None:
			vv.Message(f'Cannot load list "{listName}"')
			vv.Return(1)
		idList = list(idList)	
		L = len(idList)
		
		nPairs = []
		if SS != 0:
			for n in range(ss, L, SS):
				nPairs.append( (n,  min(L, n + SS)) )
		else:
			n = 1
			for k in range(1, L):
				if idList[k].startswith('#'):
					nPairs.append( (n, k) )
					n = k+1
			nPairs.append((n, L))
			nPairs = nPairs[ss:]
		
		for n, n2 in nPairs:
			nt = nt0.SelectColumnsById(idList[n:n2])
			nt = transform(nt)
			info = {}
			info['SQ'] = listName
			info['RG'] = f'{n}-{n2}'
			info['SS'] = str(SS)
			info['CS'] = str(nt.Columns)
			info['EP'] = str(epochs)
			info['PP'] = str(PP)
			info['EX'] = str(EX)
			info['ex'] = str(ex)
			info['DS'] = vv.Dataset.Name
			if SS == 0:	info['NM'] = idList[n-1][1:]
			vv.Map.Description = InfoToString(info)
			mds.ChangeTrainingData(nt).Reset().Start()
			if not mds.Completed:
				vv.Return(1)
			if repeats == 1:
				vv.SelectedItems = None
				mp = New.MapSnapshot().Show()
				mp.Resize(0, 0, mpWidth, mpHeight)
				mp.GlyphSize = 0.25
				mp.GlyphOpacity = 0.75
				mp.ShowMarker(False)
				mp.Title = f'SQ:{listName};RG:{n}-{n2};'
				mp.Description = vv.Map.Description
	mds.Close()
	if saveTo != None:
		SaveToAtlas(saveTo)

def LoopList2(dsList, gList, saveTo=None, epochs=1000, PP=0.05, SS=50, EX=4.0, ex=1.0):
	x0, y0 = 50, 50
	for ds in dsList:
		if ds != vv.Dataset.Name:
			vv.Folder.OpenDataset(ds)
		LoopList(gList, epochs=epochs, PP=PP, SS=SS, EX=EX, ex=ex)
		if saveTo != None:
			SaveToAtlas(saveTo, x0, y0)
		y0 += 150

def InfoFromStr(desc):
	info = {}
	for s in desc.split(';'):
		fs = s.strip().split(':', 1)
		if len(fs) < 2: 
			continue
		info[fs[0]] = fs[1]
	if 'Ids' in info:
		info['Ids'] = info['Ids'].split('|')
	return info

def InfoToString(info):
	s = ''
	for key in info:
		s += key + ':'
		if key == 'Ids':
			s += '|'.join(info[key])
		else:
			s += info[key]
		s += ';'
	return s

def ExtractFeatures(pMap):
	desc = vv.Map.Description if pMap.Name=='MainForm' else pMap.Description
	return ExtractFeatures0(desc)

def ExtractFeatures0(desc):
	info = InfoFromStr(desc)
	if 'Ids' in info:
		return info['Ids']
	sq = info['SQ']
	fs = info['RG'].split('-')
	idMon = 	list(vv.GroupManager.GetGroupLabels(sq))
	n, n2 = int(fs[0]), int(fs[1])
	idMon = idMon[n:n2]
	return idMon

def ReEmbedding(pMap):
	CheckDataset(pMap)
	info = InfoFromStr(pMap.Description)
	epochs = int(info['EP'])
	PP = float(info['PP'])
	EX = float(info['EX'])
	ex = float(info['ex']) if 'ex' in info else 1.0
	mpTitle, mpDescription = pMap.Title, pMap.Description
	mds = NewTsne(epochs, PP, EX, ex)
	ftList = ExtractFeatures(pMap)
	nt = vv.GetNumberTableView(True).SelectColumnsById(ftList)
	nt = transform(nt)
	mds.ChangeTrainingData(nt).Reset().Start()
	if not mds.Completed: return
	vv.SelectedItems = None
	map = New.MapSnapshot().Show()
	map.Resize(0, 0, mpWidth, mpHeight)
	map.Title, map.Description = mpTitle, mpDescription
	mds.Close()
	vv.Map.Description = mpDescription

def MonitorMap(pMap):
	CheckDataset(pMap)
	StartTracing(ExtractFeatures(pMap), pMap)

def ShowGeneDetails():
	fm = vv.EventSource.Form
	if (fm.Name == 'HeatMap') and not fm.AttributeMode:
		return
	if fm.SelectedItems.Count < 1:
		return
	gId = fm.SelectedItems[0]
	vv.StartProcess(f'https://useast.ensembl.org/Human/Search/Results?q={gId};site=ensembl;facet_species=Human')
	vv.StartProcess(f'https://www.ncbi.nlm.nih.gov/gene/?term={gId}')

def ShowData(pMap):
	CheckDataset(pMap)
	ShowData0(ExtractFeatures(pMap))

def ShowData0(featureList):
	nt = vv.Dataset.GetNumberTableEnabled().SelectColumnsById(featureList)
	if nt.Rows*nt.Columns == 0:
		vv.Message('No data selected')
		vv.Return()
	nt = transform(nt)	
	hm = nt.ShowHeatMap()
	hm.Title = f'Data Dimension: {nt.Rows}x{nt.Columns}'
	hm.Resize(0, 0, 1015, 500)
	hm.ReadOnly = True
	hm.SelectionMode = 1
	id2sym = GetId2Sym()
	for cs in nt.ColumnSpecList: 
		cs.Name = id2sym(cs.Id)
	hm.AddContextMenu("Atlas/Gene Detail", "@ShowGeneDetails()")
	hm.NormalizeView()

def ShowExpress3D(pMap):
	CheckDataset(pMap)
	nt = vv.GetNumberTableView(True).SelectColumnsById(ExtractFeatures(pMap))
	nt = transform(nt)
	tb = mm.ToNumpy(nt)
	tb = np.sqrt((tb**2).sum(axis=1))
	MAXV = 500.0
	maxV = min(MAXV, tb.max())
	tb = MAXV/maxV*tb
	m3d = New.Map3DView(pMap.BodyListEnabled())
	m3d.MapDepth = MAXV
	m3d.Title = f'Maximum Expression: {maxV:.3g}'
	for k, b in enumerate(m3d.BodyList): b.Z = tb[k]
	Config3DMap( m3d )

def GetGeneList(chrName):
	ds = vv.Folder.ReadDataset("Gene Features")
	gList = []
	for k in range(ds.Rows):
		if ds.ValueAtAsString(k, 4) != 'protein_coding': continue
		if not chrName == 'MT':
			if ds.ValueAtAsDouble(k, 6) == 0 : continue
			if ds.ValueAtAsDouble(k, 7) == 0 : continue
		id = ds.BodyList[k].Id
		chr = ds.ValueAtAsString(k, 0)
		pos = int(ds.ValueAtAsDouble(k, 2))
		if chr == chrName:
			gList.append((id, pos))
	gList.sort(key=lambda x:x[1])
	return [p[0] for p in gList]

def EmbedGenes(idMon, epochs=1000, PP=0.05, EX=4.0, ex=1.0, repeats=1):
	if idMon.Count == 0:
		idMon = ExtractFeatures0(vv.Map.Description)
		info = InfoFromStr(vv.Map.Description)
		if 'SQ' in info:
			dtSrc = f'SQ:{info["SQ"]};RG:{info["RG"]}'
		else:
			dtSrc = 'Ids:' + '|'.join(idMon)
	else:
		dtSrc = 'Ids:' + '|'.join(idMon)
	mds = NewTsne(epochs, PP, EX, ex, repeats)
	nt = vv.GetNumberTableView(True).SelectColumnsById(idMon)
	nt = transform(nt)
	vv.Map.Description = f'EP:{epochs};PP:{PP};ex:{ex};EX:{EX};DS:{vv.Dataset.Name};CS:{nt.Columns};{dtSrc}'
	mds.ChangeTrainingData(nt).Reset().Start()
	if not mds.Completed: vv.Return(0)
	mds.Close()

def OnGenesSelected():
	mp = pp
	selected = vv.SelectedItems
	nt = vv.EventSource.Argument.SelectColumnsById(selected)
	if nt.Columns == 0:
		return
	id2sym = GetId2Sym()
	selected = [ id2sym(id) for id in selected]
	mp.Title = f'Genes: {';'.join(selected)}'
	tb = mm.ToNumpy(nt)
	tb = (tb**2).sum(axis=1)
	tbMax = max(0.05, tb.max())
	minV = 0.01 * tbMax
	maxV = 0.9 * tbMax
	stepSize = (maxV - minV)/64
	bList = mp.BodyListEnabled()
	for k, b in enumerate(bList):
		v = tb[k] - minV
		if v <= 0:
			b.Type = 0
			b.Hidden = True
		else:
			b.Type = min(15, int( v/stepSize ))
			b.Hidden = False
	reversing = False  # show the supression instead of activation
	if reversing: 
		for b in bList:
			b.Type = 15 - b.Type
	mp.RedrawBodiesType()

def ShowActiveCells(pMap):
	CheckDataset(pMap)
	pMap.SelectedItems = None
	mp = New.MapSnapshot().Show() if pMap.Name == 'MainForm' else pMap.NewSnapshot()
	mp.HiddenBodyColor = New.Color('Red')
	for b in mp.BodyList: 
		b.Hidden = True
	mp.GlyphSet = 'Ordered 64'
	mp.HiddenBodySize = 2
	mp.GlyphSize = 1.0
	mp.GlyphOpacity = 0.5
	mp.ReloadGlyphSet()
	mp.ShowMarker(False)
	mp.RedrawAll()
	nt = vv.GetNumberTableView(True).SelectColumnsById(ExtractFeatures(pMap))
	nt = cs.Transform(nt)
	vv.EventManager.OnItemsSelected("@OnGenesSelected()", mp, nt)

def SaveToAtlas(atName=None, x0=50, y0=50):
	vv.AtlasManager.OpenAtlas(atName).CaptureAllOpenViews(x0, y0).Close()

def SetAtlasItemName():
	atlas = pp
	for item in atlas.GetSelectedItems():
		mp = item.Open()
		info = InfoFromStr(mp.Title)
		item.Name = info['SQ'] + ':' + info['RG']
		item.LabelStyle = 2
		mp.Close()
		atlas.RedrawItem(item, True)

def CheckDataset(pMap):
	info = vv.Map.Description if pMap.Name=='MainForm' else pMap.Description
	dsName = InfoFromStr(info)['DS']
	if dsName != vv.Dataset.Name:
		vv.Folder.OpenDataset(dsName)	

def AdjustAtlasMaps(mpWidth, mpHeight, gSize, gOpacity):
	for it in pp.GetSelectedItems():
		mp = it.Open()
		mp.GlyphSize = gSize
		mp.GlyphOpacity = gOpacity
		mp.Resize(0,0,mpWidth,mpHeight)
		mp.Close()

# --------- Labelling related ----------

class DominantGenes:
	def __init__(self, initStr = None):
		self.geneDic = {}
		if initStr != None:
			for id in initStr.split('|'):
				self.Lookup(id)

	def Idx2Chr(self, idx):
		if idx >= 2*26:
			#return '|'
			return str(idx)+'.'
		offset = 65 if idx < 26 else 71
		return chr(offset + idx)

	def Label2Id(self, label):
		ids = []
		ss = ''
		for c in label:
			if c == '.':
				ids.append(int(ss))
				ss = ''
			elif c.isdigit():
				ss += c
			else: # must be an alphat
				n = ord(c)
				n -= 65 if n <= 90 else (97-26)
				ids.append(n)
		idList = list(self.geneDic.keys())
		L = len(idList)
		return [idList[k] for k in ids if k < L ]

	def Label2Sym(self, label):
		idList = self.Label2Id(label)
		id2sym = GetId2Sym()
		return [ id2sym(id) for id in idList ]

	def Lookup(self, geneId):
		if geneId not in self.geneDic:
			self.geneDic[geneId] = len(self.geneDic)
		idx = self.geneDic[geneId]
		return self.Idx2Chr(idx)

	def GeneList(self):
		return self.geneDic.keys()

	def ToString(self):
		return '|'.join(list(self.geneDic.keys()))

# del dKeys
def InitDominantGenes():
	global dKeys
	if vv.ModifierKeys.ControlPressed:
		del dKeys
	if 'dKeys' not in globals():
		dKeys = DominantGenes()

def MakeLabel(nt, geneList): 
	id2index = {id:k for k, id in enumerate(geneList)}
	vs = [item.Value for item in nt.ColumnMean()]
	largeV = ThresholdHi(vs)
	if largeV == 0:
		return '\u25a0'
	nm = ''
	for k, v in enumerate(vs):
		if v > largeV:	
			nm += dKeys.Lookup(nt.ColumnSpecList[k].Id)
	if len(nm) == 0: 
		nm = '\u25a0'
	return nm

def MakeLegend(geneList):
	symTable = ''
	id2sym = GetId2Sym()	
	for id in dKeys.GeneList():
		symTable += f'{dKeys.Lookup(id)}: {id2sym(id)}\n'
	return symTable

def ShowLegend(pMap):
	info = InfoFromStr(pp.Description)
	keyTable = DominantGenes(info['DG']) 
	id2sym = GetId2Sym()	
	sTable = ''
	if 'DS' in info: sTable += info['DS'] + '\n'
	if 'SQ' in info: sTable += info['SQ'] + ':' + info['RG'] + '\n\n'
	for id in keyTable.GeneList():
		sTable += f'{keyTable.Lookup(id)}: {id2sym(id)}\n'
	tp = New.TextPanel('Dominant Genes', sTable)
	tp.BackgroundColor = pMap.BackgroundColor
	tp.TextColor = New.Color('Yellow')
	tp.Show();

	
def LabelGenes(pMap): 
	CheckDataset(pMap)
	InitDominantGenes()
	if pMap.Tag == None:
		geneList = ExtractFeatures(pMap)
		baseNT = vv.Dataset.GetNumberTableEnabled().SelectColumnsById(geneList)
		pMap.MapLayout.NameLabelColor = New.Color('Yellow')
		symLegend = New.TextPanel("Gene Symbols", "").Show()
		symLegend.AlwaysOnTop = True
		InitDominantGenes()
		pMap.Tag = (baseNT, symLegend, geneList)
	(baseNT, symLegend, geneList) = pMap.Tag
	nt = baseNT.SelectRowsByIdView(pMap.SelectedItems)
	b = cs.MeanPoint(pMap.GetSelectedBodies())
	b.Name, b.ShowName = MakeLabel(nt, geneList), True
	pMap.RedrawAll()
	symLegend.Text = MakeLegend(geneList)

def GroupByType(bList):
	G = {}
	for b in bList:
		if b.Type not in G: 
			G[b.Type] = []
		G[b.Type].append(b)
	return G.values()

def LabelAllClusters(pMap):
	CheckDataset(pMap)
	geneList = ExtractFeatures(pMap)
	baseNT = vv.Dataset.GetNumberTableEnabled().SelectColumnsById(geneList)
	InitDominantGenes()
	for b in pMap.BodyList:
		b.Name, b.ShowName = '', False
	bList = [b for b in pMap.BodyListEnabled() if not b.Hidden]
	for B in GroupByType(bList):
		nt = baseNT.SelectRowsByIdView([b.Id for b in B])
		b = cs.MeanPoint(B)
		b.Name, b.ShowName = MakeLabel(nt, geneList), True
		pMap.RedrawAll()
	info = InfoFromStr(pMap.Description)
	info['DG'] = dKeys.ToString()
	pMap.Description = InfoToString(info)
	ShowLegend(pMap)

def UnifyTwoMaps(mpA, mpB):
	global dKeys
	bListA = [b for b in mpA.BodyListEnabled() if not b.Hidden]
	bListB = [b for b in mpB.BodyListEnabled() if not b.Hidden]


	#Unify the labels
	infoA = InfoFromStr(mpA.Description)
	infoB = InfoFromStr(mpB.Description)
	if ('DG' not in infoA) or ('DG' not in infoA):
		vv.Message('No dominant genes created in one of the maps')
		return
	dKeysA = DominantGenes(infoA['DG'])
	dKeysB = DominantGenes(infoB['DG'])
	bList = [ b for b in bListB if b.ShowName ]
	for b in bListB:
		gs = dKeysB.Label2Id(b.Name)
		b.Name = ''.join( [dKeysA.Lookup(id) for id in gs] )
	infoB['DG'] = dKeysA.ToString()
	mpB.Description = InfoToString(infoB)
	mpB.RedrawAll()
	gIdList = dKeysA.GeneList()
	dKeys = dKeysA
	New.TextPanel("Gene Symbols", MakeLegend(gIdList)).Show()

	#Unify the cluster color indexes:
	cA = {b.Type:b.Name for b in bListA if b.ShowName}
	cB = {b.Type:b.Name for b in bListB if b.ShowName}

	#
	# For the case that multiple clusters share a label, we sort cA and cB 
	# in ascending and descending order, so that we first match 
	# colors of large clusters. Notice cA is sorted in ascending order, in lb2clrA
	# large cluster will overwrite small clusters
	#
	from collections import Counter
	wA = Counter([b.Type for b in bListA])
	wB = Counter([b.Type for b in bListB])
	cA = {k:cA[k] for k in sorted(cA, key=lambda t:wA[t], reverse=False)}
	cB = {k:cB[k] for k in sorted(cB, key=lambda t:wB[t], reverse=True)}
	lb2clrA = {cA[t]:t for t in cA}  

	cTr = {}      # transform colors of mpB to avoid conflict
	usedB = set() # color types used by B, is basically set(cTr.values()).
	idxFree = 0   # starting index to search for free color index.
	for t in cB:       # for each color type in mpB.
		lb = cB[t]
		if (lb in lb2clrA) and (lb2clrA[lb] not in usedB):
			cTr[t] = lb2clrA[lb]
			usedB.add( lb2clrA[lb] )
		else:
			if t not in usedB:
				cTr[t] = t
				usedB.add( t )
			else:
				for k in range(idxFree, 1000):
					if (k not in usedB) and (k not in cA):
						break;
				cTr[t] = k
				usedB.add(k)
				idxFree = k+1
	for b in bListB:
		b.Type = cTr[b.Type]
	mpB.RedrawAll()


'''=================================================================================
mpList = vv.FindFormList('MapSnapshot')
UnifyTwoMaps(mpList[0], mpList[1])

LoopList('Angiogenesis', epochs=2000, SS=50)

LoopList('lncRNA_sorted', epochs=2000, SS=400, saveTo='lncRNA')

LoopList('lncRNA_Pos', epochs=2000, SS=200, saveTo='lncRNA')

LoopList(['ChrX', 'ChrMT'], epochs=2000, SS=100)

#dsList = ['TCellBreast', 'Perivascular', 'Vascular-C', 'BreastCancel', 'Myeloid']
dsList = ['Perivascular']
ftList = ['LncRNA_Pos', 'LncRNA_Length']
LoopList2(dsList, ftList, saveTo='LncRNA', SS=500, epochs=2000, ex=0.95)

'''
