# CascadingTsne.pyn
#
# This file contains scripts to create multiple maps/embeddings from dataset, 
# then concatenate these maps and embed them in to a single map via tSNE.
#
# -------------------------------------------------------------
import math, numpy

# storage table for intermediate embedding maps.
dsMap = None
dsMap3D = False     # using 3D intermediate maps

TYPE_SEG = 0
ARC_SEG = 1
RADIO_SEG = 2
WEIGHT_SEG = 3

CENTERS_VP = 0
INTPO_VP = 1
HIGHLIGHT_VP = 2

#-------------------------------------------------------------------------------------

def NewTsneMachine(ds, mtr='Correlation.Cosine Distance',
		epochs=2000, ppl=0.05, ex0=6.0, ex1=1.0, is3D=False):
	tt = New.MdsCluster( ds )
	tt.Show()
	tt.Metric = mtr
	tt.Repeats = 1
	tt.ReadOnly = True
	tt.MaxLoops = epochs
	tt.Is3D = is3D
	tt.InitialExaggeration = ex0
	tt.FinalExaggeration = ex1
	tt.PerplexityRatio = ppl
	tt.AutoScalingTsne = True
	tt.AutoNormalizing = True
	tt.ExaggerationSmoothen = True
	tt.StagedTraining = False
	tt.AddContextMenu("Show Map Dataset", "@ShowMapDataset()")
	return tt

# Merge all intermediated maps dsMap into a single output map.
def CreateCascadingMap(ds, epochs=2000, ppl=0.05, 
		repeats=2, desc="OutMap", is3D=False):
	tt = NewTsneMachine(ds, epochs=epochs, ppl=ppl, is3D=is3D)
	tt.Metric = 'EuclideanMetric'
	tt.Repeats = repeats
	tt.Reset().Start()
	vv.Sleep(250)
	tt.Close()
	vwList = vv.FindFormList('MapSnapshot')
	cnt = len(vwList)
	if cnt >= repeats:
		for k in range(repeats):
			vw = vwList[cnt-repeats+k]
			vw.Title = desc + f'; Repeat: {k+1}'

#----------------------------

def ShowColunmsAsMap():
	mp = pp.Tag
	mpDim = pp.ScrollingSteps
	if pp.SelectedItems.Count == mpDim:
		firstColumn = min(list(dsMap.IndexOfColumns(pp.SelectedItems)))
		if firstColumn % mpDim == 0:
			bList = New.BodyList(pp.GetSelectedNumberTable())
			if (mp == None) or mp.IsDisposed:
				mp = New.MapSnapshot2(bList, vv.Map).Show()
				mp.MapType = 103 if mpDim == 3 else 102
				if mpDim == 2:
					for b in mp.BodyList: b.Z = 0
				pp.Tag = mp
			else:
				if mp.Tag != firstColumn:
					mp.MoveBodiesTo(bList, 30, 50)
			mp.Tag = firstColumn 

def FlipMap(flipUpDown):
	if pp.SelectedItems.Count != pp.ScrollingSteps:
		return
	nt = pp.GetNumberTable()
	mp = pp.Tag
	if mp is not None: 
		label = '&Transform Map/Flip Map '
		label += '&Up-Down' if flipUpDown else '&Left-Right'
		mp.ClickMenu(label)
		nt.CopyValuesFrom(mp.BodyList, (pp.ScrollingSteps==3), int(mp.Tag))

# Show the intermediate map data in a heatmap
def ShowMapDataset() :
	hm = dsMap.ShowHeatMap()
	hm.Tag = None
	hm.ScrollingSteps = 3 if dsMap.CS[2].Group == dsMap.CS[1].Group else 2
	hm.SelectionMode = 1	
	hm.NormalizeView()
	hm.AddContextMenu('Flip Up-Down', '@FlipMap(True)')
	hm.AddContextMenu('Flip Left-Right', '@FlipMap(False)')
	hm.AddEventHandler('ItemsSelected', '@ShowColunmsAsMap()')

#---------------------------- 

def AddMap2Dataset(ds, bsList, is3D, columns, ty, info=''):
	ds.CopyValuesFrom(bsList, is3D, columns)
	mpDim = 3 if is3D else 2
	for k in range(mpDim):
		ds.CS[columns+k].Group = ty+1
	vv.Echo(f'Map data added: {ty}' + info)

# Merge all open snapshots into a single dataset and display it as a heatmap.
def ConcatSnapshots():
	mList = vv.FindFormList('MapSnapshot')
	if mList.Count == 0:
		vv.Message('No snapshots present')
		vv.Return()
	dimSum = sum([m.MapLayout.Dimension for m in mList])
	ds = New.NumberTable(mList[0].BodyList, dimSum)
	offset = 0
	for k, mp in enumerate(mList):
		mpDim = mp.MapLayout.Dimension
		AddMap2Dataset(ds, mp.BodyList, mpDim==3, offset, k)
		offset += mpDim
		mp.Close()
	ds.ShowHeatMap()
	return ds

# Sort a list of points via nearst-neighbor.
def SerializeBodies( bList ):
	s = next(filter(lambda b:b.IsFixed, bList))
	bList.remove(s)
	bs = []
	while( len(bList) > 0 ):
		minDist = 1e8
		minIdx = -1
		for k, b in enumerate(bList):
			dx = b.X - s.X
			dy = b.Y - s.Y
			dd = dx*dx + dy*dy
			if dd < minDist:
				minDist = dd
				minIdx = k
		bs.append( s )
		s = bList[minIdx]
		bList.remove(s)
	return bs

def Do_MergeMaps(desc='Test'):
	CreateCascadingMap(dsMap, epochs=2000, ppl=0.1, repeats=2, is3D=False, desc=desc)

#-------------------------------------------------------------------------------------

def ArcSegmentation(K):
	cx, cy = numpy.average([(b.X, b.Y) for b in pp.BodyList], axis=0)
	ss = 2.0*math.pi/K
	shift = math.pi + 0.5 * ss
	for b in pp.BodyList:
	  alpha = math.atan2(b.Y-cy, b.X-cx) + shift
	  b.Type = int(alpha/ss) % K
	pp.RedrawBodies()

def RadioSegmentation(K):
   cx, cy = numpy.average([(b.X, b.Y) for b in pp.BodyList], axis=0)
   minR, maxR = 1e18, 0
   for b in pp.BodyList:
      dx, dy = b.X - cx, b.Y - cy
      R = dx*dx + dy*dy
      minR, maxR = min(minR, R), max(maxR, R)
   minR, maxR = math.sqrt(minR), math.sqrt(maxR)
   ss = (maxR - minR)/K
   for b in pp.BodyList:
      dx, dy = b.X - cx, b.Y - cy
      R = math.sqrt(dx*dx + dy*dy)
      b.Type = min(int(R/ss), K-1)
   pp.RedrawBodies()

def WeightSegmentation(K):
	bs = pp.BodyList
	nt = vv.GetNumberTableView(True)
	colWeight = [math.log(1+math.fabs(it.Value*nt.Rows)) for it in nt.ColumnMean()]
	colIdxes = nt.IndexOfColumns([b.Id for b in bs])	
	minW, maxW = 1e10, 0
	for i, b in enumerate(bs):
		colW = colWeight[colIdxes[i]]
		minW = min(minW, colW)
		maxW = max(maxW, colW)
	ss = (maxW - minW)/K
	for i, b in enumerate(bs):
		colW = colWeight[colIdxes[i]]
		tIdx = int((colW-minW)/ss)
		b.Type = min(tIdx, K-1)
	pp.RedrawBodies()


def Do_ByFeature(flag=TYPE_SEG, K=16):
	global dsMap
	if not hasattr(pp, 'BodyList'):
		vv.Message('This service must be called from a feature-map!')
		vv.Return(0)
	if flag==WEIGHT_SEG:
		WeightSegmentation(K)
	elif flag == ARC_SEG:
		ArcSegmentation(K)
	elif flag == RADIO_SEG:
		RadioSegmentation(K)
	ds = vv.GetNumberTableView(True)		
	tt = NewTsneMachine(ds, is3D=dsMap3D)
	mpDim = 3 if tt.Is3D else 2
	tList = {b.Type for b in pp.BodyList}
	dsMap = New.NumberTable(ds, len(tList)*mpDim)
	for k, t in enumerate(tList):
		bList = [b.Id for b in pp.BodyList if b.Type==t]
		dsM = ds.SelectColumnsById( bList )
		if dsM.Columns == 0:
			vv.Message('No feature selected! The parent window must be a feature-map!')
			vv.Return(0)
		pp.Title = f'Feature Group: {t}, Dataset: {dsM.Rows}x{dsM.Columns}'
		pp.SelectedItems = bList
		tt.SetTrainingData(dsM)	
		tt.Reset().Start().Normalize()
		if not tt.Completed: vv.Return()
		AddMap2Dataset(dsMap, tt.BodyList, (mpDim==3), k*mpDim, t)
	tt.Close()
	Do_MergeMaps(f'Alg: by-feature: {flag}')


#-------------------------------------------------------------------------------------

def VpInterpolation(ds, K):
	cc = []
	for t in [0, 1]:
		centers = ds.SelectRowsById( [r.Id for r in ds.RS if r.Type == t ] )
		cc.append( [it.Value for it in centers.ColumnMean()] )
	return numpy.linspace(cc[0], cc[1], K)

def VpByCenters(ds):
	cc = []
	tList = {r.Type for r in ds.RS if r.Type <= 60}
	for t in tList:
		rList = [r.Id for r in ds.RS if r.Type == t ]
		centers = ds.SelectRowsById(rList)
		cc.append( numpy.array( [it.Value for it in centers.ColumnMean()] ) )
	return cc

def VpHighlighted(ds):
	cc = []
	bList = [b for b in pp.Map.BodyList if b.Highlighted and not b.Disabled]
	bList = SerializeBodies(bList)
	rList = [b.Id for b in bList]
	centers = ds.SelectRowsById(rList)
	return list( mm.ToNumpy(centers) ), rList

def Do_ByViewpoint(flag=CENTERS_VP, K=16):
	global dsMap
	ds = vv.GetNumberTableView(True)
	if flag == CENTERS_VP:
		vpList = VpByCenters(ds)
	elif flag == INTPO_VP:
		vpList = VpInterpolation(ds, K)
	elif flag == HIGHLIGHT_VP:
		vpList, rList = VpHighlighted(ds)
	if len(vpList) == 0:
		vv.Message('No viewpoints have been defined!')
		vv.Return(0)
	vp = New.NumberTable(1, ds.Columns)
	tt = NewTsneMachine(ds, is3D=dsMap3D)
	mpDim = 3 if tt.Is3D else 2
	dsMap = New.NumberTable(ds, len(vpList)*mpDim)
	for k, CC in enumerate(vpList):
		mm.CopyToTable(CC, vp)
		ds.SubBy(vp)
		tt.SetTrainingData(ds)
		tt.Reset().Start().Normalize()
		ds.AddTo(vp)
		if not tt.Completed: vv.Return()
		AddMap2Dataset(dsMap, tt.BodyList, (mpDim==3), k*mpDim, k)
		if flag == HIGHLIGHT_VP:
			dsMap.CS[k*mpDim].Id = rList[k]
	tt.Close()
	Do_MergeMaps(f'Alg: by-viewpoint: {flag}')

#-------------------------------------------------------------------------------------

# Create dataset from maps extracted during the t-SNE training processes.
def CreateMapDataset(is3D=True, initSize=0.25, stepSize=0.5, 
		ppl=0.1, ex0=8.0, ex1=1.0, epochs=2000):
	global recordMarker
	global rmStepSize
	global rmInitSize
	global dsMap
	global mapCollapsed

	rmInitSize = initSize
	rmStepSize = stepSize
	recordMarker = rmInitSize
	mapCollapsed = True

	# initialize dsMap to store the intermediated maps
	maxStages = 50
	mapDim = 3 if is3D else 2
	dsMap = New.NumberTable(vv.Dataset.BodyListEnabled(), mapDim*maxStages)
	dsMap.Tag = 0

	mds = New.TsneMap()
	mds.PerplexityRatio = ppl 
	mds.InitialExaggeration = ex0
	mds.FinalExaggeration = ex1
	mds.MaxLoops = epochs
	mds.AutoNormalizing = False
	mds.AutoScaling = True
	mds.CentralizingData = True
	mds.StagedTraining = False
	mds.ExaggerationSmoothen = True
	mds.RefreshFreq = 10
	mds.Is3D = is3D
	mds.TracingType = 6
	mds.Repeats = 1
	mds.HistStepSize = 2.0
	mds.ReadOnly = True
	mds.Show()
	mds.AddContextMenu("Show Map Dataset", "@ShowMapDataset()")

	vv.Map.MapType = "Cube" if is3D else "Rectangle"
	vv.Map.Depth = 0.5 * (vv.Map.Height + vv.Map.Width)
	vv.EventManager.OnBodyMoved('@BodyMoved()', mds)
	mds.Reset().Start()
	mds.Close() if mds.Completed else vv.Return(0)
	dsMap = dsMap.SliceColumn(0, dsMap.Tag)

def BodyMoved():
	global recordMarker
	global rmStepSize
	global rmInitSize
	global dsMap
	global mapCollapsed
	
	mapDim = 3 if pp.Is3D else 2
	columns = dsMap.Tag
	span = pp.GlyphSpan

	if (span < recordMarker) and (pp.CurrentLoops != pp.MaxLoops):
		return
	if pp.CurrentLoops < 100:
		return
	if (columns + mapDim) > dsMap.Columns:
		return

	bsList = vv.Dataset.BodyListEnabled()

	# if the map was collapsed we re-check it again.
	if mapCollapsed:
		mapCollapsed = (vv.Math.Pca3DCube(bsList)[0])[mapDim-2] < 1.0
	if mapCollapsed: return

	AddMap2Dataset(dsMap, bsList, pp.Is3D, columns, int(columns/mapDim))

	recordMarker = span + math.ceil(span/3)*rmStepSize   # recordMarker for the next call.
	dsMap.Tag = columns + mapDim
	dsMap.CS[columns].Name = f'Sp:{span}'
	# Mark the cascading stages:
	curExa = float(pp.TheForm.CurrentExaggeration)+0.1
	pp.TheForm.Histogram.AddPoint(curExa, span-0.2)

def Do_Cascading():
	CreateMapDataset(is3D=dsMap3D, initSize=0.2, 
		stepSize=1.0, ex0=8.0, ex1=1.0, ppl=0.1, epochs=4000)
	Do_MergeMaps('Alg: cascading')

#-------------------------------------------------------------------------------------

cs = New.CsObject('''
public INumberTable CutLowBand(INumberTable ds, double bandWidth) {
	int L = ds.Columns;
	bool[] noZero = new bool[L];
   foreach(var R in ds.Matrix)
   for(int col=0; col<L; col++) {
      R[col] = Math.Max(0, R[col]-bandWidth);
		if (R[col] != 0) noZero[col] = true;
	}
	var ret = ds.SelectColumns(Enumerable.Range(0, L).Where(i=>noZero[i]).ToList());
	ds.FreeRef();
	return ret;
}''')

def Do_Stratify(K=5, stepSize=0.1, initSize=0.1):
	global dsMap
	ds = vv.GetNumberTableView(True).Clone()
	maxV = ds.MaximumValue()
	tt = NewTsneMachine(ds,'EuclideanMetric', is3D=dsMap3D, epochs=2000, ex0=6.0, ppl=0.1)
	mpDim = 3 if dsMap3D else 2
	dsMap = New.NumberTable(ds, mpDim*K)
	lowBW = 0
	bwList = [0, initSize]+(K-2)*[stepSize]
	for k, v in enumerate(bwList):
		ds = cs.CutLowBand(ds, v*maxV)
		lowBW += v
		tt.SetTrainingData(ds)
		tt.Reset().Start()
		if not tt.Completed: vv.Return()
		AddMap2Dataset(dsMap, tt.BodyList, tt.Is3D, k*mpDim, k,
			f';    TrnData/lowBW: {ds.Columns}/{lowBW:.3g}')
	tt.Close()
	Do_MergeMaps('Alg: Stratify')

#-------------------------------------------------------------------------------------


Do_Stratify(8, stepSize=0.05, initSize=0.35)
#Do_Cascading()

'''
for k in range(3): Do_ByViewpoint(flag=HIGHLIGHT_VP)

Do_Cascading()

Do_Stratify(8, stepSize=0.05, initSize=0.35)

Do_ByViewpoint(flag=CENTERS_VP)
Do_ByViewpoint(flag=INTPO_VP, K=16)
Do_ByViewpoint(flag=HIGHLIGHT_VP)
Do_Cascading()

pp = vv.AtlasManager.OpenMap("Vescular", "i4")
Do_ByFeature(flag=TYPE_SEG)
Do_ByFeature(flag=WEIGHT_SEG, K=4)
Do_ByFeature(flag=ARC_SEG, K=4)
Do_ByFeature(flag=RADIO_SEG, K=5)
pp.Close()

ShowMapDataset()

Do_MergeMaps()

dsMap = pp.GetNumberTable()

'''
