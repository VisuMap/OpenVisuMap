# CascadingTsne.pyn
#
# This file contains scripts to create multiple maps/embeddings from dataset, 
# then concatenate these maps and embed them in to a single map via tSNE.
#
# -------------------------------------------------------------
import math, time
import numpy as np

# storage table for intermediate embedding maps.
dsMap = None
dsMap3D = False

TYPE_SEG = 0
ARC_SEG = 1
RADIO_SEG = 2
WEIGHT_SEG = 3

CENTERS_VP = 0
INTPO_VP = 1
HIGHLIGHT_VP = 2

#-------------------------------------------------------------------------------------

def NewTsneMachine(ds, epochs=2000, ppl=0.05, is3D=False):
	tt = New.MdsCluster( ds )
	tt.Show()
	tt.Metric = 'Correlation.Cosine Distance'
	tt.Repeats = 1
	tt.ReadOnly = True
	tt.MaxLoops = epochs
	tt.Is3D = is3D
	tt.InitialExaggeration = 6.0
	tt.FinalExaggeration = 1.0
	tt.PerplexityRatio = ppl
	tt.AutoScalingTsne = True
	tt.AutoNormalizing = True
	tt.ExaggerationSmoothen = True
	tt.StagedTraining = False
	return tt

# Merge all intermediated maps dsMap into a single output map.
def CreateCascadingMap(ds, epochs=2000, ppl=0.05, 
		repeats=2, desc="OutMap", is3D=False):
	tt = NewTsneMachine(ds, epochs=epochs, ppl=ppl, is3D=is3D)
	tt.Metric = 'EuclideanMetric'
	tt.Repeats = repeats
	tt.Reset().Start().Close()
	vwList = vv.FindFormList('MapSnapshot')
	cnt = len(vwList)
	if cnt >= repeats:
		for k in range(repeats):
			vw = vwList[cnt-repeats+k]
			vw.Title = desc + f'; Repeat: {k+1}'

# Show the intermediate map data in a heatmap
def ShowMapDataset():
	hm = dsMap.ShowHeatMap()
	cc = dsMap.ColumnSpecList
	hm.ScrollingSteps = 3 if cc[2].Group == cc[1].Group else 2
	hm.SelectionMode = 1
	hm.AddEventHandler('ItemsSelected', 
		'''@if pp.SelectedItems.Count == pp.ScrollingSteps:
		bsList = New.BodyList(pp.GetSelectedNumberTable())  
		New.MapSnapshot(bsList).Show()
		''')

def AddMap2Dataset(ds, bsList, is3D, columns, ty):
	ds.CopyValuesFrom(bsList, is3D, columns)
	mpDim = 3 if is3D else 2
	for k in range(mpDim):
		ds.ColumnSpecList[columns+k].Group = ty
	vv.Echo(f'Map data added: {ty}')

# Merge all open snapshots into a single dataset and display it as a heatmap.
def ConcatSnapshots():
	mList = vv.FindFormList('MapSnapshot')
	if mList.Count == 0:
		vv.Message('No snapshots present')
		vv.Return()
	dimSum = sum([m.MapLayout.Dimension for m in mList])
	ds = New.NumberTable(mList[0].BodyList, dimSum)
	offset = 0
	for k, mp in enumerate(mList):
		mpDim = mp.MapLayout.Dimension
		AddMap2Dataset(ds, mp.BodyList, mpDim==3, offset, k)
		offset += mpDim
		mp.Close()
	ds.ShowHeatMap()
	return ds


def Do_MergeMaps(desc='Test'):
	CreateCascadingMap(dsMap, epochs=2000, ppl=0.1, repeats=2, is3D=False, desc=desc)

#-------------------------------------------------------------------------------------

def ArcSegmentation(K):
	cx, cy = np.average([(b.X, b.Y) for b in pp.BodyList], axis=0)
	ss = 2.0*math.pi/K
	shift = math.pi + 0.5 * ss
	for b in pp.BodyList:
	  alpha = math.atan2(b.Y-cy, b.X-cx) + shift
	  b.Type = int(alpha/ss) % K
	pp.RedrawBodies()

def RadioSegmentation(K):
   cx, cy = np.average([(b.X, b.Y) for b in pp.BodyList], axis=0)
   minR, maxR = 1e18, 0
   for b in pp.BodyList:
      dx, dy = b.X - cx, b.Y - cy
      R = dx*dx + dy*dy
      minR, maxR = min(minR, R), max(maxR, R)
   minR, maxR = math.sqrt(minR), math.sqrt(maxR)
   ss = (maxR - minR)/K
   for b in pp.BodyList:
      dx, dy = b.X - cx, b.Y - cy
      R = math.sqrt(dx*dx + dy*dy)
      b.Type = min(int(R/ss), K-1)
   pp.RedrawBodies()

def WeightSegmentation(K):
	bs = pp.BodyList
	nt = vv.GetNumberTableView(True)
	colWeight = [math.log(1+math.fabs(it.Value*nt.Rows)) for it in nt.ColumnMean()]
	colIdxes = nt.IndexOfColumns([b.Id for b in bs])	
	minW, maxW = 1e10, 0
	for i, b in enumerate(bs):
		colW = colWeight[colIdxes[i]]
		minW = min(minW, colW)
		maxW = max(maxW, colW)
	ss = (maxW - minW)/K
	for i, b in enumerate(bs):
		colW = colWeight[colIdxes[i]]
		tIdx = int((colW-minW)/ss)
		b.Type = min(tIdx, K-1)
	pp.RedrawBodies()


def Do_ByFeature(flag=TYPE_SEG, K=16):
	global dsMap
	if not hasattr(pp, 'BodyList'):
		vv.Message('This service must be called from a feature-map!')
		vv.Return(0)
	if flag==WEIGHT_SEG:
		WeightSegmentation(K)
	elif flag == ARC_SEG:
		ArcSegmentation(K)
	elif flag == RADIO_SEG:
		RadioSegmentation(K)
	ds = vv.GetNumberTableView(True)		
	tt = NewTsneMachine(ds, is3D=dsMap3D)
	mpDim = 3 if tt.Is3D else 2
	tList = {b.Type for b in pp.BodyList}
	dsMap = New.NumberTable(ds, len(tList)*mpDim)
	for k, t in enumerate(tList):
		bList = [b.Id for b in pp.BodyList if b.Type==t]
		dsM = ds.SelectColumnsById( bList )
		if dsM.Columns == 0:
			vv.Message('No feature selected! The parent window must be a feature-map!')
			vv.Return(0)
		pp.Title = f'Feature Group: {t}, Dataset: {dsM.Rows}x{dsM.Columns}'
		pp.SelectedItems = bList
		tt.SetTrainingData(dsM)	
		tt.Reset().Start().Normalize()
		if not tt.Completed: vv.Return()
		AddMap2Dataset(dsMap, tt.BodyList, (mpDim==3), k*mpDim, t)
	tt.Close()
	Do_MergeMaps(f'Alg: by-feature: {flag}')


#-------------------------------------------------------------------------------------

def VpInterpolation(ds, K):
	cc = []
	for t in [0, 1]:
		centers = ds.SelectRowsById( [r.Id for r in ds.RowSpecList if r.Type == t ] )
		cc.append( [it.Value for it in centers.ColumnMean()] )
	return np.linspace(cc[0], cc[1], K)

def VpByCenters(ds):
	cc = []
	tList = {r.Type for r in ds.RowSpecList if r.Type <= 60}
	for t in tList:
		rList = [r.Id for r in ds.RowSpecList if r.Type == t ]
		centers = ds.SelectRowsById(rList)
		cc.append( np.array( [it.Value for it in centers.ColumnMean()] ) )
	return cc

def VpExplicite(ds):
	cc = []
	rList = [b.Id for b in pp.Map.BodyList if b.Highlighted and not b.Disabled]
	centers = ds.SelectRowsById(rList)
	return list( mm.ToNumpy(centers) )

def Do_ByViewpoint(flag=CENTERS_VP, K=16):
	global dsMap
	ds = vv.GetNumberTableView(True)
	if flag == CENTERS_VP:
		vpList = VpByCenters(ds)
	elif flag == INTPO_VP:
		vpList = VpInterpolation(ds, K)
	elif flag == HIGHLIGHT_VP:
		vpList = VpExplicite(ds)
	if len(vpList) == 0:
		vv.Message('No viewpoints have been defined!')
		vv.Return(0)
	vp = New.NumberTable(1, ds.Columns)
	tt = NewTsneMachine(ds, is3D=dsMap3D)
	mpDim = 3 if tt.Is3D else 2
	dsMap = New.NumberTable(ds, len(vpList)*mpDim)
	for k, CC in enumerate(vpList):
		mm.CopyToTable(CC, vp)
		ds.SubBy(vp)
		tt.SetTrainingData(ds)
		tt.Reset().Start().Normalize()
		ds.AddTo(vp)
		if not tt.Completed: vv.Return()
		AddMap2Dataset(dsMap, tt.BodyList, (mpDim==3), k*mpDim, k)
	tt.Close()
	Do_MergeMaps(f'Alg: by-viewpoint: {flag}')

#-------------------------------------------------------------------------------------

# Create dataset from maps extracted during the t-SNE training processes.
def CreateMapDataset(is3D=True, initSize=0.25, stepSize=0.5, 
		ppl=0.1, ex0=8.0, ex1=1.0, epochs=2000):
	global recordMarker
	global rmStepSize
	global rmInitSize
	global dsMap
	global mapCollapsed

	rmInitSize = initSize
	rmStepSize = stepSize
	recordMarker = rmInitSize
	mapCollapsed = True

	# initialize dsMap to store the intermediated maps
	maxStages = 50
	mapDim = 3 if is3D else 2
	dsMap = New.NumberTable(vv.Dataset.BodyListEnabled(), mapDim*maxStages)
	dsMap.Tag = 0

	mds = New.TsneMap()
	mds.PerplexityRatio = ppl 
	mds.InitialExaggeration = ex0
	mds.FinalExaggeration = ex1
	mds.MaxLoops = epochs
	mds.AutoNormalizing = False
	mds.AutoScaling = True
	mds.CentralizingData = True
	mds.StagedTraining = False
	mds.ExaggerationSmoothen = True
	mds.RefreshFreq = 10
	mds.Is3D = is3D
	mds.TracingType = 6
	mds.Repeats = 1
	mds.HistStepSize = 2.0
	mds.ReadOnly = True
	mds.Show()

	vv.Map.MapType = "Cube" if is3D else "Rectangle"
	vv.Map.Depth = 0.5 * (vv.Map.Height + vv.Map.Width)
	vv.EventManager.OnBodyMoved('@BodyMoved()', mds)
	mds.Reset().Start()
	mds.Close() if mds.Completed else vv.Return(0)
	dsMap = dsMap.SliceColumn(0, dsMap.Tag)

def BodyMoved():
	global recordMarker
	global rmStepSize
	global rmInitSize
	global dsMap
	global mapCollapsed
	
	mapDim = 3 if pp.Is3D else 2
	columns = dsMap.Tag
	span = pp.GlyphSpan

	if (span < recordMarker) and (pp.CurrentLoops != pp.MaxLoops):
		return
	if pp.CurrentLoops < 100:
		return
	if (columns + mapDim) > dsMap.Columns:
		return

	bsList = vv.Dataset.BodyListEnabled()

	# if the map was collapsed we re-check it again.
	if mapCollapsed:
		mapCollapsed = (vv.Math.Pca3DCube(bsList)[0])[mapDim-2] < 1.0
	if mapCollapsed: return

	AddMap2Dataset(dsMap, bsList, pp.Is3D, columns, int(columns/mapDim))

	recordMarker = span + math.ceil(span/3)*rmStepSize   # recordMarker for the next call.
	dsMap.Tag = columns + mapDim
	dsMap.ColumnSpecList[columns].Name = f'Sp:{span}'
	# Mark the cascading stages:
	curExa = float(pp.TheForm.CurrentExaggeration)+0.1
	pp.TheForm.Histogram.AddPoint(curExa, span-0.2)

def Do_Cascading():
	CreateMapDataset(is3D=dsMap3D, initSize=0.2, 
		stepSize=1.0, ex0=8.0, ex1=1.0, ppl=0.1, epochs=4000)
	Do_MergeMaps('Alg: cascading')


#-------------------------------------------------------------------------------------

Do_Cascading()

'''
Do_ByViewpoint(flag=CENTERS_VP)
Do_ByViewpoint(flag=INTPO_VP, K=16)
Do_ByViewpoint(flag=HIGHLIGHT_VP)
Do_Cascading()

pp = vv.AtlasManager.OpenMap("Vescular", "i4")
Do_ByFeature(flag=TYPE_SEG)
Do_ByFeature(flag=WEIGHT_SEG, K=4)
Do_ByFeature(flag=ARC_SEG,   K=4)
Do_ByFeature(flag=RADIO_SEG, K=5)
pp.Close()

ShowMapDataset()

mapList = [f't-SNE{k}' for k in range(8)]
for mp in mapList: 
	vv.Dataset.OpenMap(mp)
	New.MapSnapshot(True).Show()
vv.GuiManager.CloseAllWindows()

dsMap = ConcatSnapshots()

Do_MergeMaps()

'''
