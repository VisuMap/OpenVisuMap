# TrainModel.pyn
#
vv.Import('ModellingHelp.pyn')
from torch.utils.data import DataLoader
import time

X, Y = GetTrainData()
XX, YY = Np2T(X), Np2T(Y)
mdc.NN = NeuralNetwork([X.shape[1], 100, 50, 25, Y.shape[1]])
mdc.EnableLog()
mdc.epochs = 500

def TrainModel(NN, XX, YY):	
	mapDs = MapDataset(XX, YY)
	batchDs = DataLoader(dataset=mapDs, batch_size=100, shuffle=True)
	optimizer = torch.optim.Adagrad(NN.parameters(), lr=0.005)
	loss_func = torch.nn.MSELoss()	
	mdc.stopTraining = False
	startTime = time.time()
	for t in range(mdc.epochs):
		cost = 0
		for bX, bY in batchDs:
			loss = loss_func(NN(bX), bY)
			optimizer.zero_grad()
			loss.backward()
			optimizer.step()
			cost += loss.data.cpu().numpy()
			vv.Sleep(0)
		cost /= len(batchDs)
		if ((t+1)%mdc.reportFreq == 0) and (mdc.log != None):
			mdc.log.AddStep(float(cost))
			mdc.log.Title = 'Eochs: ' + str(t+1)
		if mdc.stopTraining:
			break
	mdc.trainingTime = time.time() - startTime

TrainModel(mdc.NN, XX, YY)
ShowPred(mdc.NN, XX, Y)
