# TrainModel.pyn
#
vv.Import('ModellingHelp.pyn')
from torch.utils.data import Dataset, DataLoader
import time

X, Y = GetTrainData()
XX, YY = Np2T(X), Np2T(Y)
mdc.NN = NeuralNetwork([X.shape[1], 30, 25, 10, Y.shape[1]])
mdc.EnableLog()
mdc.epochs = 1000*60

def TrainModel(NN, XX, YY):	
	mapDs = MapDataset(XX, YY)
	batchDs = DataLoader(dataset=mapDs, batch_size=200, shuffle=True)
	optimizer = torch.optim.Adadelta(NN.parameters(), lr=0.1)
	loss_func = torch.nn.MSELoss()	
	startTime = time.time()
	for t in range(mdc.epochs):
		cost = 0
		for bX, bY in batchDs:
			loss = loss_func(NN(bX), bY)
			optimizer.zero_grad()
			loss.backward()
			optimizer.step()
			cost += loss.data.cpu().numpy()
			vv.Sleep(0)
		cost /= len(batchDs)
		if ((t+1)%mdc.reportFreq == 0) and (mdc.log != None):
			mdc.log.AddStep(float(cost))
			mdc.log.Title = 'Eochs: ' + str(t+1)
	mdc.trainingTime = time.time() - startTime


def TrainModel2(NN, XX, YY):	
	optimizer = torch.optim.Adadelta(NN.parameters(), lr=0.1)
	loss_func = torch.nn.MSELoss()	
	startTime = time.time()
	for t in range(mdc.epochs):
		loss = loss_func(NN(XX), YY)
		optimizer.zero_grad()
		loss.backward()
		optimizer.step()
		vv.Sleep(0)
		if ((t+1)%mdc.reportFreq  == 0) and (mdc.log != None):
			mdc.log.AddStep(float(loss.data.cpu().numpy()))
			mdc.log.Title = 'Eochs: ' + str(t+1)
	mdc.trainingTime = time.time() - startTime

TrainModel2(mdc.NN, XX, YY)
ShowPred(mdc.NN, XX, Y)
